import toml from '@iarna/toml';
import { assertDefined, iter } from '@votingworks/basics';
import { execFile as callbackExecFile } from 'node:child_process';
import { createReadStream, createWriteStream } from 'node:fs';
import * as fs from 'node:fs/promises';
import { pipeline } from 'node:stream/promises';
import { promisify } from 'node:util';
import yargs from 'yargs/yargs';
import {
  checkTypescriptOutputTempFilepath,
  configFilepath,
  logEventIdsOutputFilepath,
  logEventIdsTemplateFilepath,
} from './filepaths';
import {
  GenerateTypesArgs,
  LoggingConfig,
  diffAndCleanUp,
  parseConfig,
} from './types';

const execFile = promisify(callbackExecFile);

async function prepareOutputFile(filepath: string): Promise<void> {
  await fs.copyFile(logEventIdsTemplateFilepath, filepath);
  await fs.appendFile(filepath, '\n');
}

function* generateEnum(
  name: string,
  entries: Map<string, string>
): Generator<string> {
  yield `export enum ${name} {\n`;
  for (const [enumMember, value] of entries) {
    yield `${enumMember} = '${value}',\n`;
  }
  yield '}\n';
}

function* generateLogDetails(config: LoggingConfig): Generator<string> {
  for (const [titleCaseEventId, details] of config.events) {
    const [eventTypeEnumMember] = assertDefined(
      iter(config.eventTypes).find(
        ([, { eventType }]) => details.eventType === eventType
      )
    );

    yield `
    const ${titleCaseEventId}: LogDetails = {
      eventId: LogEventId.${titleCaseEventId},
      eventType: LogEventType.${eventTypeEnumMember},
      documentationMessage: '${details.documentationMessage}',
  `;
    if (details.defaultMessage) {
      yield `defaultMessage: '${details.defaultMessage}',`;
    }
    if (details.restrictInDocumentationToApps) {
      yield `restrictInDocumentationToApps: [${details.restrictInDocumentationToApps.map(
        (appName: string) => {
          const [appNameEnumMember] = assertDefined(
            iter(config.apps).find(([, { name }]) => appName === name)
          );
          return `AppName.${appNameEnumMember}`;
        }
      )}],
    `;
    }
    yield '};\n\n';
  }
}

// formatGetDetailsForEventId generates a function that returns a log's
// `LogDetails` object (ie. the object generated by `formatLogDetails`)
function generateGetDetailsForEventId(config: LoggingConfig): string {
  let output = `
    export function getDetailsForEventId(eventId: LogEventId): LogDetails {
      switch (eventId) {
  `;
  for (const key of config.events.keys()) {
    output += `
      case LogEventId.${key}:
        return ${key};`;
  }

  output += `
      default:
        throwIllegalValue(eventId);
    }
  }`;

  return output;
}

function* generateLogEventTypeDocumentation(
  config: LoggingConfig
): Generator<string> {
  for (const [titleCaseEventType, details] of config.eventTypes) {
    yield `
      const ${titleCaseEventType}EventDocumentation: LogEventTypeDocumentation = {
        eventType: LogEventType.${titleCaseEventType},
        documentationMessage: ${JSON.stringify(details.documentationMessage)},
      };
    `;
  }
}

function* generateGetLogEventTypeDocumentation(
  config: LoggingConfig
): Generator<string> {
  yield `
    export function getDocumentationForEventType(eventType: LogEventType): LogEventTypeDocumentation {
      switch (eventType) {
  `;
  for (const key of config.eventTypes.keys()) {
    yield `
      case LogEventType.${key}:
        return ${key}EventDocumentation;`;
  }

  yield `
      default:
        throwIllegalValue(eventType);
    }
  }`;
}

const argv: GenerateTypesArgs = yargs(process.argv.slice(2)).options({
  check: {
    type: 'boolean',
    description:
      'Check that generated output equals the existing file on disk. Does not overwrite existing file.',
  },
}).argv as GenerateTypesArgs;

async function main(): Promise<void> {
  const { check } = argv;
  const filepath = check
    ? checkTypescriptOutputTempFilepath
    : logEventIdsOutputFilepath;
  await prepareOutputFile(filepath);

  const untypedConfig = await toml.parse.stream(
    createReadStream(configFilepath)
  );
  const config = parseConfig(untypedConfig);
  const appNameConfig = new Map(
    iter(config.apps).map(
      ([enumMember, details]) => [enumMember, details.name] as const
    )
  );
  const logSourceConfig = new Map(
    iter(config.logSources).map(
      ([enumMember, details]) => [enumMember, details.source] as const
    )
  );
  const logEventTypesConfig = new Map(
    iter(config.eventTypes).map(
      ([enumMember, details]) => [enumMember, details.eventType] as const
    )
  );
  const logEventIdsConfig = new Map(
    iter(config.events).map(
      ([enumMember, details]) => [enumMember, details.eventId] as const
    )
  );

  const out = createWriteStream(filepath);

  await pipeline(async function* makeRustFile() {
    yield* createReadStream(logEventIdsTemplateFilepath);
    yield* '\n';
    yield* generateEnum('AppName', appNameConfig);
    yield* generateEnum('LogSource', logSourceConfig);
    yield* generateEnum('LogEventType', logEventTypesConfig);
    yield* generateEnum('LogEventId', logEventIdsConfig);
    yield* generateLogDetails(config);
    yield* generateGetDetailsForEventId(config);
    yield* generateLogEventTypeDocumentation(config);
    yield* generateGetLogEventTypeDocumentation(config);
  }, out);

  const { stderr } = await execFile('prettier', ['--write', filepath]);
  if (stderr) {
    throw new Error(`Error running eslint: ${stderr}`);
  }

  if (check) {
    await diffAndCleanUp(
      checkTypescriptOutputTempFilepath,
      logEventIdsOutputFilepath
    );
  }
}

void main();
