import toml from '@iarna/toml';
import fs from 'fs/promises';
import {
  configFilepath,
  logEventIdsOutputFilepath,
  logEventIdsTemplateFilepath,
} from './filepaths';
import { ParsedConfig, ParsedLogDetails, getTypedConfig } from './types';

async function prepareOutputFile(): Promise<void> {
  await fs.copyFile(logEventIdsTemplateFilepath, logEventIdsOutputFilepath);
  await fs.appendFile(logEventIdsOutputFilepath, '\n');
}

// formatLogEventIdEnum generates an enum where by convention the member name
// is a title-case event ID and the value is a kebab-case event ID
// eg.
// export enum LogEventId {
//   MyEventId = 'my-event-id',
// }
function formatLogEventIdEnum(config: ParsedConfig): string {
  const entries = Object.entries(config);
  let output = 'export enum LogEventId {\n';
  for (const [enumMember, logDetails] of entries) {
    output += `${enumMember} = '${logDetails.eventId}',\n`;
  }
  output += '}\n';
  return output;
}

// capitalize capitalizes the first character of a string and lower cases the remainder
function capitalize(input: string): string {
  if (input.length === 0) {
    return '';
  }
  if (input.length === 1) {
    return input.toUpperCase();
  }

  return input.charAt(0).toUpperCase() + input.slice(1).toLowerCase();
}

// kebabCaseToTitleCase expects an input in kebab-case and returns it in TitleCase
function kebabCaseToTitleCase(input: string): string {
  return input.split('-').map(capitalize).join('');
}

// formatSingleLogDetails generates TypeScript `LogDetails` for a single log eg.
// const ConfirmedBallot: LogDetails = {
//   eventId: 'ConfirmedBallot',
//   eventType: 'user-action',
//   documentationMessage: 'User confirmed the ballot is correct.',
// }
function formatSingleLogDetail(
  titleCaseEventId: string,
  singleConfig: ParsedLogDetails
): string {
  let output = `
    const ${titleCaseEventId}: LogDetails = {
      eventId: LogEventId.${titleCaseEventId},
      eventType: LogEventType.${kebabCaseToTitleCase(singleConfig.eventType)},
      documentationMessage: '${singleConfig.documentationMessage}',
  `;
  if (singleConfig.defaultMessage) {
    output += `defaultMessage: '${singleConfig.defaultMessage}',`;
  }
  if (singleConfig.restrictInDocumentationToApps) {
    output += `restrictInDocumentationToApps: [${singleConfig.restrictInDocumentationToApps.map(
      (logSource: string) => `LogSource.${kebabCaseToTitleCase(logSource)}`
    )}],
    `;
  }
  output += '};\n\n';
  return output;
}

// formatLogDetails generates TypeScript `LogDetails` for all logs in a config
// See `formatSingleLogDetail`
function formatLogDetails(config: ParsedConfig): string {
  const entries = Object.entries(config);
  let output = '';
  for (const [titleCaseEventId, details] of entries) {
    output += formatSingleLogDetail(titleCaseEventId, details);
  }

  return output;
}

// formatGetDetailsForEventId generates a function that returns a log's
// `LogDetails` object (ie. the object generated by `formatLogDetails`)
function formatGetDetailsForEventId(config: ParsedConfig): string {
  const keys = Object.keys(config);
  let output = `
    export function getDetailsForEventId(eventId: LogEventId): LogDetails {
      switch (eventId) {
  `;
  for (const key of keys) {
    output += `
      case LogEventId.${key}:
        return ${key};`;
  }

  output += `
      /* istanbul ignore next - compile time check for completeness */
      default:
        throwIllegalValue(eventId);
    }
  }`;

  return output;
}

async function main(): Promise<void> {
  await prepareOutputFile();

  const configString = await fs.readFile(configFilepath);
  const untypedConfig = toml.parse(configString.toString());
  const typedConfig = getTypedConfig(untypedConfig);
  await fs.appendFile(
    logEventIdsOutputFilepath,
    formatLogEventIdEnum(typedConfig)
  );
  await fs.appendFile(logEventIdsOutputFilepath, formatLogDetails(typedConfig));
  await fs.appendFile(
    logEventIdsOutputFilepath,
    formatGetDetailsForEventId(typedConfig)
  );
}

void main();
