// DO NOT EDIT THIS FILE. IT IS GENERATED AUTOMATICALLY.

/* eslint-disable */

import { z } from 'zod';

import check8601 from '@antongolub/iso8601';

const Iso8601Date = z
  .string()
  .refine(check8601, 'dates must be in ISO8601 format');

/**
 * Type for xsd:datetime values.
 */
export type DateTime = z.TypeOf<typeof Iso8601Date>;

/**
 * Schema for {@link DateTime}.
 */
export const DateTimeSchema = Iso8601Date;

/**
 * Type for xsd:date values.
 */
export type Date = z.TypeOf<typeof Iso8601Date>;

/**
 * Schema {@link Date}.
 */
export const DateSchema = Iso8601Date;

/**
 * A URI/URL.
 */
export type Uri = string;

/**
 * Schema for {@link Uri}.
 */
export const UriSchema = z.string();

/**
 * Byte data stored in a string.
 */
export type Byte = string;

/**
 * Schema for {@link Byte}.
 */
export const ByteSchema = z.string();

/**
 * An integer number, i.e. a whole number without fractional part.
 */
export type integer = number;

/**
 * Schema for {@link integer}.
 */
export const integerSchema = z.number().int();

/**
 * Restricts dateTime to require inclusion of time zone information and excludes fractional seconds. DateTimeWithZone is a subtype of dateTime.
 */
export type DateTimeWithZone = string;

/**
 * Schema for {@link DateTimeWithZone}.
 */
export const DateTimeWithZoneSchema: z.ZodSchema<DateTimeWithZone> = z.string().regex(/[0-9]{4}-(0?[1-9]|1[012])-(0?[1-9]|[12][0-9]|3[01])T(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]|(24:00:00))(Z|[+-]((0[0-9]|1[0-3]):[0-5][0-9]|14:00))/);

/**
 * A proper fractional value, represented using fractional or decimal notation. FractionalNumber is a subtype of string.
 */
export type FractionalNumber = string;

/**
 * Schema for {@link FractionalNumber}.
 */
export const FractionalNumberSchema: z.ZodSchema<FractionalNumber> = z.string().regex(/([0-9]+\/[1-9]+[0-9]*)|(\.[0-9]+)/);

/**
 * For a string containing a 6-digit Red-Green-Blue (RGB) code that can be displayed using HTML. Used in Party to associate a web-displayable color with the party. The RGB code is specified in hexadecimal, such that the RGB code for the color green is “00FF00” (“#00” + “#FF” + “#00”). HtmlColorString is a subtype of string.
 */
export type HtmlColorString = string;

/**
 * Schema for {@link HtmlColorString}.
 */
export const HtmlColorStringSchema: z.ZodSchema<HtmlColorString> = z.string().regex(/[0-9a-f]{6}/);

export enum BallotDefinitionVersion {
  /**
   * For version 1.0.0 of this specification.
   */
  v1_0_0 = '1.0.0',
}

/**
 * Schema for {@link BallotDefinitionVersion}.
 */
export const BallotDefinitionVersionSchema = z.nativeEnum(BallotDefinitionVersion);

/**
 * The side of a ballot sheet.
 */
export enum BallotSideType {
  /**
   * The back of the ballot sheet.
   */
  Back = 'back',

  /**
   * The front of the ballot sheet
   */
  Front = 'front',
}

/**
 * Schema for {@link BallotSideType}.
 */
export const BallotSideTypeSchema = z.nativeEnum(BallotSideType);

/**
 * Enumeration for the type of election in the BallotDefinition class.
 */
export enum ElectionType {
  /**
   * Election in which all eligible voters, regardless of party affiliation, are permitted to select candidates to fill public office and/or vote on ballot measures.
   */
  General = 'general',

  /**
   * Election held to determine which candidates qualify to appear as contest options in subsequent elections.
   */
  Primary = 'primary',
}

/**
 * Schema for {@link ElectionType}.
 */
export const ElectionTypeSchema = z.nativeEnum(ElectionType);

/**
 * Enumeration for election data-related codes in the ExternalIdentifier class .
 */
export enum IdentifierType {
  /**
   * For FIPS codes.
   */
  Fips = 'fips',

  /**
   * For a code that is specific to a county or other similar locality.
   */
  LocalLevel = 'local-level',

  /**
   * For a code that is used at the national level other than “fips” or “ocd-id”.
   */
  NationalLevel = 'national-level',

  /**
   * For Open Civic Data identifiers.
   */
  OcdId = 'ocd-id',

  /**
   * Used when the type of code is not included in this enumeration.
   */
  Other = 'other',

  /**
   * For a code that is specific to a state.
   */
  StateLevel = 'state-level',
}

/**
 * Schema for {@link IdentifierType}.
 */
export const IdentifierTypeSchema = z.nativeEnum(IdentifierType);

/**
 * The measurement unit for describing the location of content on a ballot.
 */
export enum MeasurementUnitType {
  /**
   * inches
   */
  In = 'in',

  /**
   * millimeters
   */
  Mm = 'mm',

  /**
   * picas
   */
  Pc = 'pc',

  /**
   * points (1/72 inch)
   */
  Pt = 'pt',
}

/**
 * Schema for {@link MeasurementUnitType}.
 */
export const MeasurementUnitTypeSchema = z.nativeEnum(MeasurementUnitType);

/**
 * The orientation of a ballot sheet.
 */
export enum OrientationType {
  /**
   * Orient the sheet so that the ballot content print across the long edge of the paper.
   */
  Landscape = 'landscape',

  /**
   * Orient the sheet so that the ballot content print across the short edge of the paper.
   */
  Portrait = 'portrait',
}

/**
 * Schema for {@link OrientationType}.
 */
export const OrientationTypeSchema = z.nativeEnum(OrientationType);

/**
 * Enumeration for the type of geopolitical unit in the ReportingUnit class.
 */
export enum ReportingUnitType {
  /**
   * Used for a county and/or for the district that encompasses it. In AK, used for counties that are called boroughs. In LA, used for parishes.
   */
  County = 'county',

  /**
   * Used also for “Ward” or “District” when these terms are used interchangeably with “Precinct”.
   */
  Precinct = 'precinct',

  /**
   * Used for splits of precincts.
   */
  SplitPrecinct = 'split-precinct',

  /**
   * Used for a state and/or for the district that encompasses it.
   */
  State = 'state',

  /**
   * Used for other types of reporting units not included in this enumeration.
   */
  Other = 'other',
}

/**
 * Schema for {@link ReportingUnitType}.
 */
export const ReportingUnitTypeSchema = z.nativeEnum(ReportingUnitType);

export enum SelectionCaptureMethod {
  /**
   * For a read method that uses the mCDF encoded using a symbology.
   */
  Mcdf = 'mcdf',

  /**
   * For a read method that uses optical mark recognition.
   */
  Omr = 'omr',
}

/**
 * Schema for {@link SelectionCaptureMethod}.
 */
export const SelectionCaptureMethodSchema = z.nativeEnum(SelectionCaptureMethod);

export enum ShapeType {
  /**
   * For an ellipse shape
   */
  Ellipse = 'ellipse',

  /**
   * For a rectangle shape
   */
  Rectangle = 'rectangle',
}

/**
 * Schema for {@link ShapeType}.
 */
export const ShapeTypeSchema = z.nativeEnum(ShapeType);

/**
 * For defining items pertaining to the issuer and version of the definition and when it was generated.
 * 
 * BallotDefinition references the major elements that are not necessarily specific to an election and that therefore can exist in a logical ballot definition: GpUnit, Office and OfficeGroup, Party, Person, and Election.
 */
export interface BallotDefinition {
  readonly '@type': 'BallotDefinition.BallotDefinition';

  /**
   * For associating ballot formats with the definition.
   */
  readonly BallotFormat: readonly BallotFormat[];

  /**
   * For associating elections with the definition.
   */
  readonly Election: readonly Election[];

  /**
   * Identifies the date and time that the ballot definition was generated.
   */
  readonly GeneratedDate: DateTimeWithZone;

  /**
   * For associating geopolitical units with the definition.
   */
  readonly GpUnit: readonly ReportingUnit[];

  /**
   * For associating headers with parts of a ballot style.
   */
  readonly Header?: readonly Header[];

  /**
   * Identification of the definition issuer.
   */
  readonly Issuer: string;

  /**
   * An abbreviation of the definition issuer such as the 2-character U.S. Census Bureau abbreviation of the state providing the election definition, e.g., AL, TX, MN, etc.
   */
  readonly IssuerAbbreviation: string;

  /**
   * For associating offices with the definition.
   */
  readonly Office?: readonly Office[];

  /**
   * For associating parties with the definition.
   */
  readonly Party: readonly Party[];

  /**
   * The upper bound of the sequence; e.g., “1” if there is only 1 report, “2” if there are two reports in the sequence, etc.
   */
  readonly SequenceEnd: integer;

  /**
   * The report's number as part of a sequence of reports, used with SequenceEnd so as to be read as, e.g., 1 of 1, 1 of 2, 2 of 2, etc.  Starts with "1".
   */
  readonly SequenceStart: integer;

  /**
   * For associating parts of the ballot with geometric shapes.
   */
  readonly Shape?: readonly Shape[];

  /**
   * An identifier of the vendor application generating the ballot definition, e.g., X-EMS version 3.1.a.
   */
  readonly VendorApplicationId: string;

  /**
   * To identify the version of the BD specification being used, i.e., version 1.0.0. This will need to be updated for different versions of the specification.
   */
  readonly Version: BallotDefinitionVersion;
}

/**
 * Schema for {@link BallotDefinition}.
 */
export const BallotDefinitionSchema: z.ZodSchema<BallotDefinition> = z.object({
  '@type': z.literal('BallotDefinition.BallotDefinition'),
  BallotFormat: z.array(z.lazy(/* istanbul ignore next */ () => BallotFormatSchema)).min(1),
  Election: z.array(z.lazy(/* istanbul ignore next */ () => ElectionSchema)).min(1),
  GeneratedDate: z.lazy(/* istanbul ignore next */ () => DateTimeWithZoneSchema),
  GpUnit: z.array(z.lazy(/* istanbul ignore next */ () => ReportingUnitSchema)).min(1),
  Header: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => HeaderSchema))),
  Issuer: z.string(),
  IssuerAbbreviation: z.string(),
  Office: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => OfficeSchema))),
  Party: z.array(z.lazy(/* istanbul ignore next */ () => PartySchema)),
  SequenceEnd: integerSchema,
  SequenceStart: integerSchema,
  Shape: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => ShapeSchema))),
  VendorApplicationId: z.string(),
  Version: z.lazy(/* istanbul ignore next */ () => BallotDefinitionVersionSchema),
});

/**
 * For providing details related to the concrete presentation of a ballot appropriate to the particular voting technology being used. All physical details of a ballot style are associated with a particular BallotFormat.
 * 
 * BallotFormat sets the MeasurementUnit appropriate for the marking surface used.
 */
export interface BallotFormat {
  readonly '@id': string;

  readonly '@type': 'BallotDefinition.BallotFormat';

  /**
   * The application that generates ballots in the ballot format.
   */
  readonly Application?: string;

  /**
   * For associating IDs with the ballot format.
   */
  readonly ExternalIdentifier: readonly ExternalIdentifier[];

  /**
   * For associating a ballot format with one or more global fiducial marks appearing on a ballot.
   */
  readonly FiducialMark?: readonly FiducialMark[];

  /**
   * Measurement of the long edge of the ballot sheet.
   */
  readonly LongEdge: number;

  /**
   * Manufacturer of the ballot format.
   */
  readonly Manufacturer?: string;

  /**
   * The measurement units used to express locations of ballot content, such as contest option positions.
   */
  readonly MeasurementUnit: MeasurementUnitType;

  /**
   * Orientation of the page relative to the coordinate plane.
   */
  readonly Orientation: OrientationType;

  /**
   * The method used to read contest selections or indications on the ballot.
   */
  readonly SelectionCaptureMethod: SelectionCaptureMethod;

  /**
   * Measurement of the short edge of the ballot sheet.
   */
  readonly ShortEdge: number;

  /**
   * For locating the data encoded using a mCDF Profile (e.g. mCDF Profile for Contest Selection Capture).
   */
  readonly mCDFArea?: readonly mCDFArea[];
}

/**
 * Schema for {@link BallotFormat}.
 */
export const BallotFormatSchema: z.ZodSchema<BallotFormat> = z.object({
  '@id': z.string(),
  '@type': z.literal('BallotDefinition.BallotFormat'),
  Application: z.optional(z.string()),
  ExternalIdentifier: z.array(z.lazy(/* istanbul ignore next */ () => ExternalIdentifierSchema)).min(1),
  FiducialMark: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => FiducialMarkSchema))),
  LongEdge: z.number(),
  Manufacturer: z.optional(z.string()),
  MeasurementUnit: z.lazy(/* istanbul ignore next */ () => MeasurementUnitTypeSchema),
  Orientation: z.lazy(/* istanbul ignore next */ () => OrientationTypeSchema),
  SelectionCaptureMethod: z.lazy(/* istanbul ignore next */ () => SelectionCaptureMethodSchema),
  ShortEdge: z.number(),
  mCDFArea: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => mCDFAreaSchema))),
});

/**
 * For ballot measure (i.e., referenda or a tax measure) and judicial retention contests. It inherits the attributes of Contest.
 * 
 * If the type of ballot measure is not listed in enumeration BallotMeasureType, use other and include the type (that is not listed in the enumeration) in OtherType.
 */
export interface BallotMeasureContest {
  readonly '@id': string;

  readonly '@type': 'BallotDefinition.BallotMeasureContest';

  /**
   * Title of the contest as it appears on the ballot.
   */
  readonly BallotTitle: InternationalizedText;

  /**
   * For associating contest options for the contest, e.g., candidates,  ballot measure options.
   */
  readonly ContestOption: readonly BallotMeasureOption[];

  /**
   * Link to a GpUnit instance. For associating the contest with a reporting unit that represents the geographical scope of the contest, e.g., a district, etc.
   */
  readonly ElectionDistrictId: string;

  /**
   * For full text on the ballot of the ballot measure.
   */
  readonly FullText: InternationalizedText;

  /**
   * Name of the contest, not necessarily as it appears on the ballot.
   */
  readonly Name: string;
}

/**
 * Schema for {@link BallotMeasureContest}.
 */
export const BallotMeasureContestSchema: z.ZodSchema<BallotMeasureContest> = z.object({
  '@id': z.string(),
  '@type': z.literal('BallotDefinition.BallotMeasureContest'),
  BallotTitle: z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema),
  ContestOption: z.array(z.lazy(/* istanbul ignore next */ () => BallotMeasureOptionSchema)).min(2),
  ElectionDistrictId: z.string(),
  FullText: z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema),
  Name: z.string(),
});

/**
 * For a contest selection in a ballot measure contest. Because judicial or other retention contests are often treated like ballot measure contests, this element can be used also for retention contests. It inherits the attributes of ContestOption.
 */
export interface BallotMeasureOption {
  readonly '@id': string;

  readonly '@type': 'BallotDefinition.BallotMeasureOption';

  /**
   * Contains the text used to indicate a vote for or against the ballot measure, e.g., “yes”, “no”.
   */
  readonly Selection: InternationalizedText;
}

/**
 * Schema for {@link BallotMeasureOption}.
 */
export const BallotMeasureOptionSchema: z.ZodSchema<BallotMeasureOption> = z.object({
  '@id': z.string(),
  '@type': z.literal('BallotDefinition.BallotMeasureOption'),
  Selection: z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema),
});

/**
 * For defining a ballot style composed of ordered content (i.e. Headers or Contests) and their contest selections, and associating the ballot style with a political party, a reference to an image of the ballot, and a reference to a precinct or other geopolitical unit that the ballot is unique to. Election includes BallotStyle.
 * BallotStyle references OrderedContent to include content that appears on that ballot style. To preserve any rotation associated with the ballot, it is expected that the generating application will list the occurrences of OrderedContest in the order as on the ballot for the associated geopolitical unit.
 * BallotStyle references one or more GpUnit instances defined for the associated precincts or split precincts. If the ballot style is associated with multiple precincts (or other geographies), multiple references to the precinct GpUnit instances can be included.
 */
export interface BallotStyle {
  readonly '@type': 'BallotDefinition.BallotStyle';

  /**
   * For associating IDs with the ballot style.
   */
  readonly ExternalIdentifier: readonly ExternalIdentifier[];

  /**
   * Unique identifier for one or more GpUnit instances.  For associating specific election administrative areas (e.g. precincts or splits) with the ballot style.
   */
  readonly GpUnitIds: readonly string[];

  /**
   * For the written languages appearing on the ballot style.
   */
  readonly Language?: readonly string[];

  /**
   * For associating a ballot style with ballot content, such as contests or headers.
   */
  readonly OrderedContent?: readonly OrderedContest[];

  /**
   * For associating one or more parties with the ballot style.
   */
  readonly PartyIds?: readonly string[];
}

/**
 * Schema for {@link BallotStyle}.
 */
export const BallotStyleSchema: z.ZodSchema<BallotStyle> = z.object({
  '@type': z.literal('BallotDefinition.BallotStyle'),
  ExternalIdentifier: z.array(z.lazy(/* istanbul ignore next */ () => ExternalIdentifierSchema)).min(1),
  GpUnitIds: z.array(z.string()).min(1),
  Language: z.optional(z.array(z.string()).min(1)),
  OrderedContent: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => OrderedContestSchema))),
  PartyIds: z.optional(z.array(z.string())),
});

/**
 * A class representing a bounding box. The box represents in absolute coordinate space its location and size. Its location is given by x,y coordinates, size by h,w values, the side of the sheet it appears on and the sheet number of the ballot style.
 * 
 * PhysicalContest includes BoundedObject.
 * BoundedObject has three subclasses, used contextually:
 * 
 * FiducialMark, included by BallotFormat
 * 
 * mCDFArea, included by BallotFormat
 * 
 * OptionPosition, included by PhysicalContestOption
 * 
 * WriteInPosition, included by PhysicalContestOption
 */
export interface BoundedObject {
  readonly '@type': 'BallotDefinition.BoundedObject';

  /**
   * Height in ballot format measurement units.
   */
  readonly H: number;

  /**
   * The ballot sheet the bounded object appears on. Sheets start at 1 and increase monotonically. Does not apply to mCDFArea, or global fiducials.
   */
  readonly Sheet?: integer;

  /**
   * The side of the sheet of paper the bounded object appears.
   */
  readonly Side: BallotSideType;

  /**
   * Width in ballot format measurement units.
   */
  readonly W: number;

  /**
   * X-coordinate for locating a bounded object (top left anchor).
   */
  readonly X: number;

  /**
   * Y-coordinate for locating a bounded object (top left anchor).
   */
  readonly Y: number;
}

/**
 * Schema for {@link BoundedObject}.
 */
export const BoundedObjectSchema: z.ZodSchema<BoundedObject> = z.object({
  '@type': z.literal('BallotDefinition.BoundedObject'),
  H: z.number(),
  Sheet: z.optional(integerSchema),
  Side: z.lazy(/* istanbul ignore next */ () => BallotSideTypeSchema),
  W: z.number(),
  X: z.number(),
  Y: z.number(),
});

/**
 * For defining information about a candidate in a contest. CandidateOption references Candidate instances to associate one or more candidates with a contest selection. Election includes Candidate.
 * 
 * Candidate uses the Party association to reference the candidate's political party. If the candidate is endorsed by other parties for a particular contest, the endorsing parties are referenced using the CandidateOption attribute.
 * 
 * ExternalIdentifier can be used to associate IDs with the candidate. If the type is not listed in enumeration IdentifierType, use other and include the type (that is not listed in the enumeration) in OtherType.
 */
export interface Candidate {
  readonly '@id': string;

  readonly '@type': 'BallotDefinition.Candidate';

  /**
   * For the candidate’s name as listed on the ballot.
   */
  readonly BallotName: InternationalizedText;
}

/**
 * Schema for {@link Candidate}.
 */
export const CandidateSchema: z.ZodSchema<Candidate> = z.object({
  '@id': z.string(),
  '@type': z.literal('BallotDefinition.Candidate'),
  BallotName: z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema),
});

/**
 * For a contest that involves selecting one or more candidates. It inherits the attributes of Contest.
 * 
 * This class optionally references Office and Party. If the candidate contest is associated with a ticket (of candidates) and each candidate in the ticket is associated with a separate office, the association to Office can reference each of the separate offices. For example, if the contest is for the state governor ticket but Governor and Lieutenant (Lt.) Governor are both separate offices, the association references first to the Office instance defined for the Governor's office and then to the Lt. Governor's office. In this case, it is expected that the generating application will list the multiple references according to a jurisdiction-defined ordering scheme, e.g., Governor first and Lt. Governor second.
 * 
 * Note that when using the CandidateOption class to associate the candidates with a contest selection for the contest, the order of the candidates should match the order of offices. Again, using the example of the state governor ticket, if the offices are listed with Governor first and Lt. Governor second, then the order of the candidates in the ContestOption instance should be identical, with the Governor candidate first and the Lt. Governor candidate second.
 */
export interface CandidateContest {
  readonly '@id': string;

  readonly '@type': 'BallotDefinition.CandidateContest';

  /**
   * Title of the contest as it appears on the ballot.
   */
  readonly BallotTitle: InternationalizedText;

  /**
   * For associating contest options for the contest, e.g., candidates,  ballot measure options.
   */
  readonly ContestOption: readonly CandidateOption[];

  /**
   * Link to a GpUnit instance. For associating the contest with a reporting unit that represents the geographical scope of the contest, e.g., a district, etc.
   */
  readonly ElectionDistrictId: string;

  /**
   * Name of the contest, not necessarily as it appears on the ballot.
   */
  readonly Name: string;

  /**
   * For associating office descriptions.
   */
  readonly OfficeIds?: readonly string[];

  /**
   * For associating parties with the contest.
   */
  readonly PrimaryPartyIds?: readonly string[];

  /**
   * Maximum number of votes per voter in this contest.
   */
  readonly VotesAllowed: integer;
}

/**
 * Schema for {@link CandidateContest}.
 */
export const CandidateContestSchema: z.ZodSchema<CandidateContest> = z.object({
  '@id': z.string(),
  '@type': z.literal('BallotDefinition.CandidateContest'),
  BallotTitle: z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema),
  ContestOption: z.array(z.lazy(/* istanbul ignore next */ () => CandidateOptionSchema)).min(1),
  ElectionDistrictId: z.string(),
  Name: z.string(),
  OfficeIds: z.optional(z.array(z.string())),
  PrimaryPartyIds: z.optional(z.array(z.string())),
  VotesAllowed: integerSchema,
});

/**
 * For the contest selections in a candidate contest, including for write-ins. It inherits the attributes of ContestOption. References to multiple Candidate instances can be included if necessary, e.g., when the contest selection would be for a ticket of candidates (unless the ticket itself is defined as a candidate).
 * 
 * EndorsementParty is used to reference any associated endorsement parties other than the specific party of the candidate (Candidate references Party for that purpose). For example, if a candidate of one party is also endorsed by a second party, use EndorsementParty to reference the second party. A second example would be for ballot fusion as used in some states, where the same candidate is listed multiple times in the same contest, but with different endorsement parties.
 * 
 * When multiple candidates are referenced for a ticket and the ordering of the candidates is important to preserve, it is expected that the generating application will list the references to Candidate instances according to the ordering scheme in place. For example, if the contest is for a ticket in which each candidate is associated with a different office, then the order of the candidates should match the same ordering of the &lt;Office&gt; element references within &lt;OfficeIds&gt; in the &lt;Contest xsi:type=&quot;CandidateContest&quot; ... /&gt; element.
 */
export interface CandidateOption {
  readonly '@id': string;

  readonly '@type': 'BallotDefinition.CandidateOption';

  /**
   * For associating a candidate with the candidate selection on the ballot and for cases where the contest selection is for multiple candidates, e.g., a ticket.
   */
  readonly CandidateIds?: readonly string[];

  /**
   * For associating one or more endorsing parties with the candidate selection.
   */
  readonly EndorsementPartyIds?: readonly string[];

  /**
   * Indicates whether the candidate is a write-in, e.g., true or false. Assumed to be false if not present.
   */
  readonly IsWriteIn?: boolean;
}

/**
 * Schema for {@link CandidateOption}.
 */
export const CandidateOptionSchema: z.ZodSchema<CandidateOption> = z.object({
  '@id': z.string(),
  '@type': z.literal('BallotDefinition.CandidateOption'),
  CandidateIds: z.optional(z.array(z.string()).min(1)),
  EndorsementPartyIds: z.optional(z.array(z.string())),
  IsWriteIn: z.optional(z.boolean()),
});

/**
 * For defining details of the election and associated information such as candidates and contests.
 * 
 * Election includes links to the major instances that are specific to an election: BallotStyle, Candidate, and Contest.
 * 
 * Election includes a required reference to ElectionScope, which links to a GpUnit instance for the purpose of identifying the geographical scope of the election. For example, for an election within a county, ElectionScope would reference a GpUnit defined for the county. If it is desired to include election authority information, the GpUnit can include ElectionAdministration.
 */
export interface Election {
  readonly '@type': 'BallotDefinition.Election';

  /**
   * For defining ballot styles associated with the election.
   */
  readonly BallotStyle: readonly BallotStyle[];

  /**
   * For defining candidates associated with the election.
   */
  readonly Candidate?: readonly Candidate[];

  /**
   * For defining contests associated with the election.
   */
  readonly Contest: ReadonlyArray<BallotMeasureContest | CandidateContest>;

  /**
   * Unique identifier for a GpUnit element. For associating the election with a reporting unit that represents the geographical scope of the election, e.g., a state, a county, etc.
   */
  readonly ElectionScopeId: string;

  /**
   * Calendar end date of the election; for a typical one-day election, the end date is the same as the start date.
   */
  readonly EndDate: Date;

  /**
   * For associating IDs with the election.
   */
  readonly ExternalIdentifier: readonly ExternalIdentifier[];

  /**
   * For including a name for the election; the name could be the same name as appears on the ballot.
   */
  readonly Name: InternationalizedText;

  /**
   * Calendar start date of the election, e.g., “2018-11-04”.
   */
  readonly StartDate: Date;

  /**
   * Enumerated type of election, e.g., partisan-primary, open-primary, etc.
   */
  readonly Type: ElectionType;
}

/**
 * Schema for {@link Election}.
 */
export const ElectionSchema: z.ZodSchema<Election> = z.object({
  '@type': z.literal('BallotDefinition.Election'),
  BallotStyle: z.array(z.lazy(/* istanbul ignore next */ () => BallotStyleSchema)).min(1),
  Candidate: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => CandidateSchema))),
  Contest: z.array(z.union([z.lazy(/* istanbul ignore next */ () => BallotMeasureContestSchema), z.lazy(/* istanbul ignore next */ () => CandidateContestSchema)])).min(1),
  ElectionScopeId: z.string(),
  EndDate: DateSchema,
  ExternalIdentifier: z.array(z.lazy(/* istanbul ignore next */ () => ExternalIdentifierSchema)).min(1),
  Name: z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema),
  StartDate: DateSchema,
  Type: z.lazy(/* istanbul ignore next */ () => ElectionTypeSchema),
});

/**
 * For associating a jurisdiction's codes, i.e., identifiers, with objects such as candidates, offices, or geopolitical units such as counties, towns, precincts, etc. Multiple occurrences of ExternalIdentifier can be used to associate multiple codes, e.g., if there is a desire to associate multiple codes with a particular object such as FIPS (Federal Information Processing Standard) codes as well as OCD-IDs (Open Civic Data Identifiers).
 * 
 * For elements that link to ExternalIdentifier instances, if the type is not listed in enumeration IdentifierType, use other and include the type (that is not listed in the enumeration) in OtherType.
 */
export interface ExternalIdentifier {
  readonly '@type': 'BallotDefinition.ExternalIdentifier';

  /**
   * For use as needed and compatibility with the VIP schema.
   */
  readonly Label?: string;

  /**
   * Used when IdentifierType value is other.
   */
  readonly OtherType?: string;

  /**
   * An identifier type, e.g., FIPS.
   */
  readonly Type: IdentifierType;

  /**
   * The identifier used by the jurisdiction.
   */
  readonly Value: string;
}

/**
 * Schema for {@link ExternalIdentifier}.
 */
export const ExternalIdentifierSchema: z.ZodSchema<ExternalIdentifier> = z.object({
  '@type': z.literal('BallotDefinition.ExternalIdentifier'),
  Label: z.optional(z.string()),
  OtherType: z.optional(z.string()),
  Type: z.lazy(/* istanbul ignore next */ () => IdentifierTypeSchema),
  Value: z.string(),
});

/**
 * FiducialMark is a subclass of BoundedObject for geometry found at fixed positions of the page. BallotFormat references FiducialMark for geometry found at fixed locations on the ballot. PhysicalContest references FiducialMark for geometry proximate to the contest.
 */
export interface FiducialMark {
  readonly '@type': 'BallotDefinition.FiducialMark';

  /**
   * Height in ballot format measurement units.
   */
  readonly H: number;

  /**
   * For associating a FiducialMark with the geometric shape that represents it.
   */
  readonly ShapeId: string;

  /**
   * The ballot sheet the bounded object appears on. Sheets start at 1 and increase monotonically. Does not apply to mCDFArea, or global fiducials.
   */
  readonly Sheet?: integer;

  /**
   * The side of the sheet of paper the bounded object appears.
   */
  readonly Side: BallotSideType;

  /**
   * Width in ballot format measurement units.
   */
  readonly W: number;

  /**
   * X-coordinate for locating a bounded object (top left anchor).
   */
  readonly X: number;

  /**
   * Y-coordinate for locating a bounded object (top left anchor).
   */
  readonly Y: number;
}

/**
 * Schema for {@link FiducialMark}.
 */
export const FiducialMarkSchema: z.ZodSchema<FiducialMark> = z.object({
  '@type': z.literal('BallotDefinition.FiducialMark'),
  H: z.number(),
  ShapeId: z.string(),
  Sheet: z.optional(integerSchema),
  Side: z.lazy(/* istanbul ignore next */ () => BallotSideTypeSchema),
  W: z.number(),
  X: z.number(),
  Y: z.number(),
});

/**
 * For defining a reusable set of headers.
 */
export interface Header {
  readonly '@id': string;

  readonly '@type': 'BallotDefinition.Header';

  /**
   * For associating an ID with the header.
   */
  readonly ExternalIdentifier?: readonly ExternalIdentifier[];

  /**
   * For textual content appearing under a header (e.g. ballot instructions).
   */
  readonly HeaderedContent?: InternationalizedText;

  /**
   * Name of the header, as it is to appear on a ballot style.
   */
  readonly Name: InternationalizedText;
}

/**
 * Schema for {@link Header}.
 */
export const HeaderSchema: z.ZodSchema<Header> = z.object({
  '@id': z.string(),
  '@type': z.literal('BallotDefinition.Header'),
  ExternalIdentifier: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => ExternalIdentifierSchema))),
  HeaderedContent: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
  Name: z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema),
});

/**
 * For strings that can contain multi-national text, for use with text as shown on a ballot containing multi-national text. The label attribute can be used to assign an identifier to the text as desired.
 * 
 * Text uses the xsd:language type such that its language attribute must be set to a value that identifies the language.
 * 
 * Values for language are from ISO 639 [12] and include:
 * 
 * en – English
 * 
 * en-US – U.S. English
 * 
 * en-GB – U.K. English
 * 
 * fr – French
 * 
 * es – Spanish
 * 
 * zh – Chinese
 * 
 * ja – Japanese
 * 
 * ko – Korean
 */
export interface InternationalizedText {
  readonly '@type': 'BallotDefinition.InternationalizedText';

  /**
   * For use as needed and compatibility with the VIP schema.
   */
  readonly Label?: string;

  /**
   * Used to hold a string of text with an associated table indicating the language used.
   */
  readonly Text: readonly LanguageString[];
}

/**
 * Schema for {@link InternationalizedText}.
 */
export const InternationalizedTextSchema: z.ZodSchema<InternationalizedText> = z.object({
  '@type': z.literal('BallotDefinition.InternationalizedText'),
  Label: z.optional(z.string()),
  Text: z.array(z.lazy(/* istanbul ignore next */ () => LanguageStringSchema)).min(1),
});

/**
 * Used to hold a string of text with an associated table indicating the language used.
 */
export interface LanguageString {
  readonly '@type': 'BallotDefinition.LanguageString';

  readonly Content: string;

  /**
   * Identification of the language, such as 'es'.
   */
  readonly Language: string;
}

/**
 * Schema for {@link LanguageString}.
 */
export const LanguageStringSchema: z.ZodSchema<LanguageString> = z.object({
  '@type': z.literal('BallotDefinition.LanguageString'),
  Content: z.string(),
  Language: z.string(),
});

/**
 * For defining an office and information associated with a contest and/or a district. BallotDefinition includes Office. CandidateContest and RetentionContest reference Office.
 * 
 * Office includes Term for defining details about the term of an office such as start/end dates and the type of term. OfficeGroup is included from BallotDefinition to assign a name to a grouping of office definitions.
 * 
 * Office includes an optional ElectionDistrict reference to a GpUnit for the purpose of identifying the geographical scope of the office. For example, for an office for a state senate seat, ElectionDistrict would include a reference to the GpUnit defined for the district associated with that office.
 */
export interface Office {
  readonly '@id': string;

  readonly '@type': 'BallotDefinition.Office';

  /**
   * Name of the office; can appear on the ballot.
   */
  readonly Name: InternationalizedText;

  /**
   * For including office term-related information.
   */
  readonly Term: Term;
}

/**
 * Schema for {@link Office}.
 */
export const OfficeSchema: z.ZodSchema<Office> = z.object({
  '@id': z.string(),
  '@type': z.literal('BallotDefinition.Office'),
  Name: z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema),
  Term: z.lazy(/* istanbul ignore next */ () => TermSchema),
});

/**
 * For associating a physical contest option to the location(s) where a selection can be indicated. It inherits the properties of BoundedObject.
 */
export interface OptionPosition {
  readonly '@type': 'BallotDefinition.OptionPosition';

  /**
   * The proper fractional number of votes represented by the option position.
   */
  readonly FractionalVotes?: FractionalNumber;

  /**
   * Height in ballot format measurement units.
   */
  readonly H: number;

  /**
   * For associating an OptionPosition with the shape that conveys the expected location of a mark.
   */
  readonly IndicatorId?: string;

  /**
   * The number of votes represented by the option position.
   */
  readonly NumberVotes: integer;

  /**
   * The rank represented by the option position, if a RCV contest.
   */
  readonly Rank?: integer;

  /**
   * The ballot sheet the bounded object appears on. Sheets start at 1 and increase monotonically. Does not apply to mCDFArea, or global fiducials.
   */
  readonly Sheet: integer;

  /**
   * The side of the sheet of paper the bounded object appears.
   */
  readonly Side: BallotSideType;

  /**
   * Width in ballot format measurement units.
   */
  readonly W: number;

  /**
   * X-coordinate for locating a bounded object (top left anchor).
   */
  readonly X: number;

  /**
   * Y-coordinate for locating a bounded object (top left anchor).
   */
  readonly Y: number;
}

/**
 * Schema for {@link OptionPosition}.
 */
export const OptionPositionSchema: z.ZodSchema<OptionPosition> = z.object({
  '@type': z.literal('BallotDefinition.OptionPosition'),
  FractionalVotes: z.optional(z.lazy(/* istanbul ignore next */ () => FractionalNumberSchema)),
  H: z.number(),
  IndicatorId: z.optional(z.string()),
  NumberVotes: integerSchema,
  Rank: z.optional(integerSchema),
  Sheet: integerSchema,
  Side: z.lazy(/* istanbul ignore next */ () => BallotSideTypeSchema),
  W: z.number(),
  X: z.number(),
  Y: z.number(),
});

/**
 * For the appearance of a contest on a particular ballot style.This property uses OrderedContent as a superclass.
 */
export interface OrderedContest {
  readonly '@type': 'BallotDefinition.OrderedContest';

  /**
   * The contest associated represented by OrderedContest.
   */
  readonly ContestId: string;

  /**
   * For describing the physical aspects of the contest.
   */
  readonly Physical: readonly PhysicalContest[];
}

/**
 * Schema for {@link OrderedContest}.
 */
export const OrderedContestSchema: z.ZodSchema<OrderedContest> = z.object({
  '@type': z.literal('BallotDefinition.OrderedContest'),
  ContestId: z.string(),
  Physical: z.array(z.lazy(/* istanbul ignore next */ () => PhysicalContestSchema)).min(1),
});

/**
 * Used to describe a political party that can then be referenced in other elements. BallotDefinition includes Party. Candidate, PartyRegistration, and Person reference Party.
 * 
 * Party is an abstract type with one subtype Coalition, used to define coalitions.
 * 
 * The Color attribute specifies a 6-digit RGB code displayable using HTML.
 */
export interface Party {
  readonly '@id': string;

  readonly '@type': 'BallotDefinition.Party';

  /**
   * Short name for the party, e.g., “DEM”.
   */
  readonly Abbreviation: InternationalizedText;

  /**
   * Official full name of the party, e.g., “Republican”; can appear on the ballot.
   */
  readonly Name: InternationalizedText;
}

/**
 * Schema for {@link Party}.
 */
export const PartySchema: z.ZodSchema<Party> = z.object({
  '@id': z.string(),
  '@type': z.literal('BallotDefinition.Party'),
  Abbreviation: z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema),
  Name: z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema),
});

/**
 * For the appearance of a contest on a particular ballot style with physical details such as the locations and shapes of contest option positions.
 */
export interface PhysicalContest {
  readonly '@type': 'BallotDefinition.PhysicalContest';

  /**
   * For associating a ballot format with a physical contest.
   */
  readonly BallotFormatId: string;

  /**
   * The extent of the contest. If the contest spans multiple sections of the ballot (e.g. columns or pages), then multiple extents may be provided.
   */
  readonly Extent?: ReadonlyArray<BoundedObject | FiducialMark | OptionPosition | WriteInPosition | mCDFArea>;

  /**
   * For associating a ordered physical contest with one or more local fiducial marks appearing near the contest.
   */
  readonly FiducialMark?: readonly FiducialMark[];

  /**
   * The contest options associated with the contest, including physical details.
   */
  readonly PhysicalContestOption: readonly PhysicalContestOption[];
}

/**
 * Schema for {@link PhysicalContest}.
 */
export const PhysicalContestSchema: z.ZodSchema<PhysicalContest> = z.object({
  '@type': z.literal('BallotDefinition.PhysicalContest'),
  BallotFormatId: z.string(),
  Extent: z.optional(z.array(z.union([z.lazy(/* istanbul ignore next */ () => BoundedObjectSchema), z.lazy(/* istanbul ignore next */ () => FiducialMarkSchema), z.lazy(/* istanbul ignore next */ () => OptionPositionSchema), z.lazy(/* istanbul ignore next */ () => WriteInPositionSchema), z.lazy(/* istanbul ignore next */ () => mCDFAreaSchema)]))),
  FiducialMark: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => FiducialMarkSchema))),
  PhysicalContestOption: z.array(z.lazy(/* istanbul ignore next */ () => PhysicalContestOptionSchema)).min(1),
});

/**
 * For associating a ContestOption to its physical manifestation. Each PhysicalContestOption is specified in terms of a particular BallotFormat. A PhysicalContestOption may have multiple OptionPosition instances, for voting methods that require it (e.g. rank choice voting). WriteInPosition specifies the response area where name(s) may written-in.
 */
export interface PhysicalContestOption {
  readonly '@type': 'BallotDefinition.PhysicalContestOption';

  /**
   * For associating a PhysicalContestOption with a ContestOption. This should always be provided unless the contest option is for a write-in.
   */
  readonly ContestOptionId: string;

  /**
   * For defining locations where a selection can be indicated.
   */
  readonly OptionPosition: readonly OptionPosition[];

  /**
   * For defining locations where a name can be hand-written.
   */
  readonly WriteInPosition?: readonly WriteInPosition[];
}

/**
 * Schema for {@link PhysicalContestOption}.
 */
export const PhysicalContestOptionSchema: z.ZodSchema<PhysicalContestOption> = z.object({
  '@type': z.literal('BallotDefinition.PhysicalContestOption'),
  ContestOptionId: z.string(),
  OptionPosition: z.array(z.lazy(/* istanbul ignore next */ () => OptionPositionSchema)).min(1),
  WriteInPosition: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => WriteInPositionSchema))),
});

/**
 * For defining a geopolitical unit such as state, county, township, precinct, etc., using the ReportingUnitType enumeration. It inherits the attributes of GpUnit.
 * 
 * This class optionally references Person to associate one or more individuals, e.g., authorities, for the reporting unit. It also includes ContactInformation to provide contact addresses for the reporting unit, such as an address of a vote center.
 * 
 * Election references this class so as to identify the geographical scope of the election. In this case, the GpUnit element defined for the scope of the election may include ElectionAdministration to include election authority-related information.
 * 
 * The Type attribute uses the ReportingUnitType enumeration to specify the type of geopolitical geography being defined. ReportingUnitType contains the most common types of geographies, e.g., state, county, precinct, and so forth. If the reporting unit type is not listed in enumeration ReportingUnitType, use other and include the reporting unit type (that is not listed in the enumeration) in OtherType.
 * 
 * The IsDistricted boolean can be used in a number of ways. It is not strictly necessary, as it is possible to identify districts by their Type attribute or by examining the Contest instance's ElectionDistrict reference, which links to the election district associated with the contest. However, if a district is defined but is not linked from a contest, or if the type of district is not listed in the ReportingUnitType enumeration and therefore OtherType is used, then IsDistricted is necessary to identify the GpUnit as a district. The IsDistricted boolean can also be used to signify that a GpUnit defined as a jurisdiction, e.g., a county, is also used as a district for, e.g., county-wide contests.
 */
export interface ReportingUnit {
  readonly '@id': string;

  readonly '@type': 'BallotDefinition.ReportingUnit';

  /**
   * Unique identifier for one or more GpUnit instances.  For creating a reference to another GpUnit that is contained with the parent GpUnit.
   */
  readonly ComposingGpUnitIds?: readonly string[];

  /**
   * Name of the geopolitical unit.
   */
  readonly Name: InternationalizedText;

  /**
   * Enumerated type of reporting unit, e.g., state, county, district, precinct, etc.
   */
  readonly Type: ReportingUnitType;
}

/**
 * Schema for {@link ReportingUnit}.
 */
export const ReportingUnitSchema: z.ZodSchema<ReportingUnit> = z.object({
  '@id': z.string(),
  '@type': z.literal('BallotDefinition.ReportingUnit'),
  ComposingGpUnitIds: z.optional(z.array(z.string())),
  Name: z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema),
  Type: z.lazy(/* istanbul ignore next */ () => ReportingUnitTypeSchema),
});

/**
 * For defining a geometric shape. Geometry can be used to represent content on a physical ballot style, such as for associating an OptionPosition to its shape. It is also used by FiducialMark to define the shape it takes..
 * 
 * Strokes when applied, are applied evenhanded.
 */
export interface Shape {
  readonly '@id': string;

  readonly '@type': 'BallotDefinition.Shape';

  /**
   * For fiducial marks only. If not specified, no fill is assumed.
   */
  readonly FillColor?: HtmlColorString;

  /**
   * The shape this Geometry represents.
   */
  readonly ShapeType: ShapeType;

  /**
   * The color of the stroke. If no color is specified, assume black (what XFA does)
   */
  readonly StrokeColor?: HtmlColorString;

  /**
   * The width of the stroke in the measurement units of the BallotFormat associated with the PhysicalContest.
   */
  readonly StrokeWidth?: number;
}

/**
 * Schema for {@link Shape}.
 */
export const ShapeSchema: z.ZodSchema<Shape> = z.object({
  '@id': z.string(),
  '@type': z.literal('BallotDefinition.Shape'),
  FillColor: z.optional(z.lazy(/* istanbul ignore next */ () => HtmlColorStringSchema)),
  ShapeType: z.lazy(/* istanbul ignore next */ () => ShapeTypeSchema),
  StrokeColor: z.optional(z.lazy(/* istanbul ignore next */ () => HtmlColorStringSchema)),
  StrokeWidth: z.optional(z.number()),
});

/**
 * For describing information about an office term. Term is included by Office.
 */
export interface Term {
  readonly '@type': 'BallotDefinition.Term';

  /**
   * For use as needed and compatibility with the VIP schema.
   */
  readonly Label: string;
}

/**
 * Schema for {@link Term}.
 */
export const TermSchema: z.ZodSchema<Term> = z.object({
  '@type': z.literal('BallotDefinition.Term'),
  Label: z.string(),
});

/**
 * Response area for representing a particular candidate, e.g. John Smith hand printed. It inherits the properties of BoundedObject.
 */
export interface WriteInPosition {
  readonly '@type': 'BallotDefinition.WriteInPosition';

  /**
   * Height in ballot format measurement units.
   */
  readonly H: number;

  /**
   * Whether a selection in an OptionPosition is required in order to count the write-in. Assumed to be false if not present.
   */
  readonly SelectionRequired?: boolean;

  /**
   * The ballot sheet the bounded object appears on. Sheets start at 1 and increase monotonically. Does not apply to mCDFArea, or global fiducials.
   */
  readonly Sheet?: integer;

  /**
   * The side of the sheet of paper the bounded object appears.
   */
  readonly Side: BallotSideType;

  /**
   * Width in ballot format measurement units.
   */
  readonly W: number;

  /**
   * X-coordinate for locating a bounded object (top left anchor).
   */
  readonly X: number;

  /**
   * Y-coordinate for locating a bounded object (top left anchor).
   */
  readonly Y: number;
}

/**
 * Schema for {@link WriteInPosition}.
 */
export const WriteInPositionSchema: z.ZodSchema<WriteInPosition> = z.object({
  '@type': z.literal('BallotDefinition.WriteInPosition'),
  H: z.number(),
  SelectionRequired: z.optional(z.boolean()),
  Sheet: z.optional(integerSchema),
  Side: z.lazy(/* istanbul ignore next */ () => BallotSideTypeSchema),
  W: z.number(),
  X: z.number(),
  Y: z.number(),
});

/**
 * A part of the ballot containing an instantiation of the microCDF. It inherits the properties of BoundedObject.
 */
export interface mCDFArea {
  readonly '@type': 'BallotDefinition.mCDFArea';

  /**
   * Height in ballot format measurement units.
   */
  readonly H: number;

  /**
   * The ballot sheet the bounded object appears on. Sheets start at 1 and increase monotonically. Does not apply to mCDFArea, or global fiducials.
   */
  readonly Sheet?: integer;

  /**
   * The side of the sheet of paper the bounded object appears.
   */
  readonly Side: BallotSideType;

  /**
   * The name of the symbology used.
   */
  readonly Symbology: string;

  /**
   * Width in ballot format measurement units.
   */
  readonly W: number;

  /**
   * X-coordinate for locating a bounded object (top left anchor).
   */
  readonly X: number;

  /**
   * Y-coordinate for locating a bounded object (top left anchor).
   */
  readonly Y: number;
}

/**
 * Schema for {@link mCDFArea}.
 */
export const mCDFAreaSchema: z.ZodSchema<mCDFArea> = z.object({
  '@type': z.literal('BallotDefinition.mCDFArea'),
  H: z.number(),
  Sheet: z.optional(integerSchema),
  Side: z.lazy(/* istanbul ignore next */ () => BallotSideTypeSchema),
  Symbology: z.string(),
  W: z.number(),
  X: z.number(),
  Y: z.number(),
});

