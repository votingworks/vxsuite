// DO NOT EDIT THIS FILE. IT IS GENERATED AUTOMATICALLY.

/* eslint-disable */

import { z } from 'zod';

import check8601 from '@antongolub/iso8601';

const Iso8601Date = z
  .string()
  .refine(check8601, 'dates must be in ISO8601 format');

/**
 * Type for xsd:datetime values.
 */
export type DateTime = z.TypeOf<typeof Iso8601Date>;

/**
 * Schema for {@link DateTime}.
 */
export const DateTimeSchema = Iso8601Date;

/**
 * Type for xsd:date values.
 */
export type Date = z.TypeOf<typeof Iso8601Date>;

/**
 * Schema {@link Date}.
 */
export const DateSchema = Iso8601Date;

/**
 * A URI/URL.
 */
export type Uri = string;

/**
 * Schema for {@link Uri}.
 */
export const UriSchema = z.string();

/**
 * Byte data stored in a string.
 */
export type Byte = string;

/**
 * Schema for {@link Byte}.
 */
export const ByteSchema = z.string();

/**
 * An integer number, i.e. a whole number without fractional part.
 */
export type integer = number;

/**
 * Schema for {@link integer}.
 */
export const integerSchema = z.number().int();

/**
 * Restricts dateTime to require inclusion of time zone information and excludes fractional seconds.
 */
export type DateTimeWithZone = string;

/**
 * Schema for {@link DateTimeWithZone}.
 */
export const DateTimeWithZoneSchema: z.ZodSchema<DateTimeWithZone> = z.string().regex(/[0-9]{4}-(0?[1-9]|1[012])-(0?[1-9]|[12][0-9]|3[01])T(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]|(24:00:00))(Z|[+-]((0[0-9]|1[0-3]):[0-5][0-9]|14:00))/);

/**
 * For a string containing a 6-digit Red-Green-Blue (RGB) code that can be displayed using HTML. Used in Party to associate a web-displayable color with the party. The RGB code is specified in hexadecimal, such that the RGB code for the color green is “00FF00” (“#00” + “#FF” + “#00”).
 */
export type HtmlColorString = string;

/**
 * Schema for {@link HtmlColorString}.
 */
export const HtmlColorStringSchema: z.ZodSchema<HtmlColorString> = z.string().regex(/[0-9a-f]{6}/);

/**
 * For defining a 32-character annotation, used with character strings in AnnotatedString.
 */
export type ShortString = string;

/**
 * Schema for {@link ShortString}.
 */
export const ShortStringSchema: z.ZodSchema<ShortString> = z.string();

/**
 * Restricts time to require inclusion of time zone information and excludes fractional seconds
 */
export type TimeWithZone = string;

/**
 * Schema for {@link TimeWithZone}.
 */
export const TimeWithZoneSchema: z.ZodSchema<TimeWithZone> = z.string().regex(/(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]|(24:00:00))(Z|[+-]((0[0-9]|1[0-3]):[0-5][0-9]|14:00))/);

/**
 * Enumeration for types of ballot measures in the BallotMeasureContest element.
 */
export enum BallotMeasureType {
  /**
   * For reports that contain only aggregated counts.
   */
  BallotMeasure = 'ballot-measure',

  /**
   * For an initiative.
   */
  Initiative = 'initiative',

  /**
   * Used when the type of ballot measure is not included in this enumeration.
   */
  Other = 'other',

  /**
   * For a recall.
   */
  Recall = 'recall',

  /**
   * For a referendum.
   */
  Referendum = 'referendum',
}

/**
 * Schema for {@link BallotMeasureType}.
 */
export const BallotMeasureTypeSchema = z.nativeEnum(BallotMeasureType);

/**
 * Enumeration for various post-election statuses applicable to a candidate in the Candidate element.
 */
export enum CandidatePostElectionStatus {
  /**
   * For candidates who have advanced to a runoff.
   */
  AdvancedToRunoff = 'advanced-to-runoff',

  /**
   * Used for candidates who were defeated in the election.
   */
  Defeated = 'defeated',

  /**
   * For a projected contest winner.
   */
  ProjectedWinner = 'projected-winner',

  /**
   * For the official contest winner or one of “n” contest winners for n-of-m voting.
   */
  Winner = 'winner',

  /**
   * For candidates who have withdrawn from the contest.
   */
  Withdrawn = 'withdrawn',
}

/**
 * Schema for {@link CandidatePostElectionStatus}.
 */
export const CandidatePostElectionStatusSchema = z.nativeEnum(CandidatePostElectionStatus);

/**
 * Enumeration for various pre-election statuses applicable to a candidate
 *       in the Candidate
 *       class.
 */
export enum CandidatePreElectionStatus {
  /**
   * For candidates who have filed with the election authority but not necessarily qualified.
   */
  Filed = 'filed',

  /**
   * For candidates who are qualified by the election authority to be on the ballot for a contest.
   */
  Qualified = 'qualified',

  /**
   * For candidates who have withdrawn from the contest.
   */
  Withdrawn = 'withdrawn',
}

/**
 * Schema for {@link CandidatePreElectionStatus}.
 */
export const CandidatePreElectionStatusSchema = z.nativeEnum(CandidatePreElectionStatus);

/**
 * Enumeration for various counting-related statuses for types of ballots or write-ins, used in the CountStatus class.
 */
export enum CountItemStatus {
  /**
   * For counts that are complete.
   */
  Completed = 'completed',

  /**
   * For counts that are in process.
   */
  InProcess = 'in-process',

  /**
   * When the counting has not started or is not underway.
   */
  NotProcessed = 'not-processed',

  /**
   * When the status of the counting is unknown.
   */
  Unknown = 'unknown',
}

/**
 * Schema for {@link CountItemStatus}.
 */
export const CountItemStatusSchema = z.nativeEnum(CountItemStatus);

/**
 * Enumeration for the items that are counted during the course of an election and for which the status of the counts is of interest. Used in the Counts and CountStatus classes.
 */
export enum CountItemType {
  /**
   * For any/all classes of absentee, generally when absentee is not broken out into specific classes.
   */
  Absentee = 'absentee',

  /**
   * A type of absentee; for Federal Write-in Absentee Ballots.
   */
  AbsenteeFwab = 'absentee-fwab',

  /**
   * A class of absentee; for absentee ballots cast in-person, e.g., at a county office.
   */
  AbsenteeInPerson = 'absentee-in-person',

  /**
   * A class of absentee; for postal mail absentee ballots separately.
   */
  AbsenteeMail = 'absentee-mail',

  /**
   * For ballots cast during early voting periods.
   */
  Early = 'early',

  /**
   * For ballots cast on election day.
   */
  ElectionDay = 'election-day',

  /**
   * Used when the type of counting item is not included in this enumeration.
   */
  Other = 'other',

  /**
   * For challenged ballots.
   */
  Provisional = 'provisional',

  /**
   * For legislative balance-of-power results information.
   */
  Seats = 'seats',

  /**
   * Total of all ballots cast regardless of voting class.
   */
  Total = 'total',

  /**
   * A class of absentee; for absentee ballots from Uniformed and Overseas Citizens Absentee Voting Act (UOCAVA) voters.
   */
  Uocava = 'uocava',

  /**
   * For write-ins on ballots.
   */
  WriteIn = 'write-in',
}

/**
 * Schema for {@link CountItemType}.
 */
export const CountItemTypeSchema = z.nativeEnum(CountItemType);

/**
 * Enumeration for the day(s) in a schedule in the Schedule element.
 */
export enum DayType {
  /**
   * Used for all days of the week.
   */
  All = 'all',

  /**
   * Used if day of week is Friday.
   */
  Friday = 'friday',

  /**
   * Used if day of week is Monday.
   */
  Monday = 'monday',

  /**
   * Used if day of week is Saturday.
   */
  Saturday = 'saturday',

  /**
   * Used if day of week is Sunday.
   */
  Sunday = 'sunday',

  /**
   * Used if day of week is Thursday.
   */
  Thursday = 'thursday',

  /**
   * Used if day of week is Tuesday.
   */
  Tuesday = 'tuesday',

  /**
   * Used if day of week is Wednesday.
   */
  Wednesday = 'wednesday',

  /**
   * Used for any day of the week.
   */
  Weekday = 'weekday',

  /**
   * Used for both Saturday and Sunday.
   */
  Weekend = 'weekend',
}

/**
 * Schema for {@link DayType}.
 */
export const DayTypeSchema = z.nativeEnum(DayType);

/**
 * Enumeration for the type of device in the DeviceClass class.
 */
export enum DeviceType {
  /**
   * For ballots prepared on ballot marking devices and then scanned.
   */
  Bmd = 'bmd',

  /**
   * For DRE (Direct Record Electronic) and other all-electronic devices.
   */
  Dre = 'dre',

  /**
   * For hand-counted paper ballots.
   */
  ManualCount = 'manual-count',

  /**
   * For an optical scanner used at a central office with no opportunity for voter correction of mistakes.
   */
  OpscanCentral = 'opscan-central',

  /**
   * For an optical scanner used at a precinct or other location where voter correction of mistakes such as overvotes is possible.
   */
  OpscanPrecinct = 'opscan-precinct',

  /**
   * Used when the device type is not listed in this enumeration.
   */
  Other = 'other',

  /**
   * Used when the type of device is unknown.
   */
  Unknown = 'unknown',
}

/**
 * Schema for {@link DeviceType}.
 */
export const DeviceTypeSchema = z.nativeEnum(DeviceType);

/**
 * Enumeration for the type of election in the ElectionReport class.
 */
export enum ElectionType {
  /**
   * Election in which all eligible voters, regardless of party affiliation, are permitted to select candidates to fill public office and/or vote on ballot measures.
   */
  General = 'general',

  /**
   * Used when the election type is not listed in this enumeration.
   */
  Other = 'other',

  /**
   * Primary election in which the voter receives a ballot containing only those party-specific contests pertaining to the political party with which the voter is affiliated, along with non-party-specific contests presented at the same election. Unaffiliated voters may be permitted to vote only on non-party-specific contests.
   */
  PartisanPrimaryClosed = 'partisan-primary-closed',

  /**
   * Primary election in which the voter may choose a political party at the time of voting and vote in party-specific contests associated with that party, along with non-party-specific contests presented at the same election. Some states require voters to publicly declare their choice of party at the polling place, after which the election worker provides or activates the appropriate ballot. Other states allow the voters to make their choice of party within the privacy of the voting booth.
   */
  PartisanPrimaryOpen = 'partisan-primary-open',

  /**
   * Election held to determine which candidates qualify to appear as contest options in subsequent elections.
   */
  Primary = 'primary',

  /**
   * Election to select a winner following a primary or a general election, in which no candidate in the contest received the required minimum percentage of the votes cast. The two candidates receiving the most votes for the contest in question proceed to a runoff election.
   */
  Runoff = 'runoff',

  /**
   * Primary or general election that is not regularly scheduled. A special election may be combined with a scheduled election.
   */
  Special = 'special',
}

/**
 * Schema for {@link ElectionType}.
 */
export const ElectionTypeSchema = z.nativeEnum(ElectionType);

/**
 * Enumeration for geospatial vector data formats used in Geographic Information System (GIS) software, used in the SpatialExtent class.
 */
export enum GeoSpatialFormat {
  /**
   * For GeoJSON open standard format.
   */
  GeoJson = 'geo-json',

  /**
   * For Geography Markup Language format.
   */
  Gml = 'gml',

  /**
   * For Keyhole Markup Language format.
   */
  Kml = 'kml',

  /**
   * For the shape file format associated with Esri.
   */
  Shp = 'shp',

  /**
   * For Well-known Text format.
   */
  Wkt = 'wkt',
}

/**
 * Schema for {@link GeoSpatialFormat}.
 */
export const GeoSpatialFormatSchema = z.nativeEnum(GeoSpatialFormat);

/**
 * Enumeration for election data-related codes in the ExternalIdentifier class .
 */
export enum IdentifierType {
  /**
   * For FIPS codes.
   */
  Fips = 'fips',

  /**
   * For a code that is specific to a county or other similar locality.
   */
  LocalLevel = 'local-level',

  /**
   * For a code that is used at the national level other than “fips” or “ocd-id”.
   */
  NationalLevel = 'national-level',

  /**
   * For Open Civic Data identifiers.
   */
  OcdId = 'ocd-id',

  /**
   * Used when the type of code is not included in this enumeration.
   */
  Other = 'other',

  /**
   * For a code that is specific to a state.
   */
  StateLevel = 'state-level',
}

/**
 * Schema for {@link IdentifierType}.
 */
export const IdentifierTypeSchema = z.nativeEnum(IdentifierType);

/**
 * Enumeration for the office term type in the Office class.
 */
export enum OfficeTermType {
  /**
   * When the officeholder’s term began at the beginning of the full term of the office, e.g., 6 years for U.S. Senate.
   */
  FullTerm = 'full-term',

  /**
   * When the officeholder’s term began at some date after the beginning of the full term of the office, generally because the previous officeholder vacated the office before the fullterm expired.
   */
  UnexpiredTerm = 'unexpired-term',
}

/**
 * Schema for {@link OfficeTermType}.
 */
export const OfficeTermTypeSchema = z.nativeEnum(OfficeTermType);

/**
 * Enumeration for the detail level of the election results report in the Election class.
 */
export enum ReportDetailLevel {
  /**
   * For reports that contain counts from precincts in the reporting jurisdiction.
   */
  PrecinctLevel = 'precinct-level',

  /**
   * For reports that contain only aggregated counts.
   */
  SummaryContest = 'summary-contest',
}

/**
 * Schema for {@link ReportDetailLevel}.
 */
export const ReportDetailLevelSchema = z.nativeEnum(ReportDetailLevel);

/**
 * Enumeration for the type of geopolitical unit in the ReportingUnit class.
 */
export enum ReportingUnitType {
  /**
   * Used for reporting batches of ballots that may cross precinct boundaries.
   */
  BallotBatch = 'ballot-batch',

  /**
   * Used for ballot style areas generally composed of precincts.
   */
  BallotStyleArea = 'ballot-style-area',

  /**
   * Used in CT, NJ, PA, other states, and New York City for boroughs. For AK and LA, see county.
   */
  Borough = 'borough',

  /**
   * Used for a city that reports results and/or for the district that encompasses it.
   */
  City = 'city',

  /**
   * Used for city council districts.
   */
  CityCouncil = 'city-council',

  /**
   * Used for one or more precincts that have been combined for the purposes of reporting. Used for “Ward” if “Ward” is used interchangeably with “CombinedPrecinct”.
   */
  CombinedPrecinct = 'combined-precinct',

  /**
   * Used for U.S. Congressional districts.
   */
  Congressional = 'congressional',

  /**
   * Used for a reporting unit of type country.
   */
  Country = 'country',

  /**
   * Used for a county and/or for the district that encompasses it. In AK, used for counties that are called boroughs. In LA, used for parishes.
   */
  County = 'county',

  /**
   * Used for county council districts.
   */
  CountyCouncil = 'county-council',

  /**
   * Used for a dropbox for absentee ballots.
   */
  DropBox = 'drop-box',

  /**
   * Used for judicial districts.
   */
  Judicial = 'judicial',

  /**
   * Used as applicable for various units such as towns, townships, villages that report votes and/or for the district that encompasses it.
   */
  Municipality = 'municipality',

  /**
   * Used for other types of reporting units not included in this enumeration.
   */
  Other = 'other',

  /**
   * Used for a polling place.
   */
  PollingPlace = 'polling-place',

  /**
   * Used also for “Ward” or “District” when these terms are used interchangeably with “Precinct”.
   */
  Precinct = 'precinct',

  /**
   * Used for a school district.
   */
  School = 'school',

  /**
   * Used for a special district.
   */
  Special = 'special',

  /**
   * Used for splits of precincts.
   */
  SplitPrecinct = 'split-precinct',

  /**
   * Used for a state and/or for the district that encompasses it.
   */
  State = 'state',

  /**
   * Used for a state house or assembly district.
   */
  StateHouse = 'state-house',

  /**
   * Used for a state senate district.
   */
  StateSenate = 'state-senate',

  /**
   * Used in some New England states as a type of municipality that reports votes and/or for the district that encompasses it.
   */
  Town = 'town',

  /**
   * Used in some mid-western states as a type of municipality that reports votes and/or for the district that encompasses it.
   */
  Township = 'township',

  /**
   * Used for a utility district.
   */
  Utility = 'utility',

  /**
   * Used as a type of municipality that reports votes and/or for the district that encompasses it.
   */
  Village = 'village',

  /**
   * Used for a vote center.
   */
  VoteCenter = 'vote-center',

  /**
   * Used for combinations or groupings of precincts or other units.
   */
  Ward = 'ward',

  /**
   * Used for a water district.
   */
  Water = 'water',
}

/**
 * Schema for {@link ReportingUnitType}.
 */
export const ReportingUnitTypeSchema = z.nativeEnum(ReportingUnitType);

/**
 * Enumeration for the status of the election results in the ElectionReport class.
 */
export enum ResultsStatus {
  /**
   * For results that have been certified by the election authority.
   */
  Certified = 'certified',

  /**
   * For results that are a correction to an earlier report.
   */
  Correction = 'correction',

  /**
   * For a pre-election data.
   */
  PreElection = 'pre-election',

  /**
   * For results that are a recount of an earlier election.
   */
  Recount = 'recount',

  /**
   * For results that are unofficial and complete, e.g., the complete election night results.
   */
  UnofficialComplete = 'unofficial-complete',

  /**
   * For results that are unofficial and partial, e.g., partial election night results.
   */
  UnofficialPartial = 'unofficial-partial',
}

/**
 * Schema for {@link ResultsStatus}.
 */
export const ResultsStatusSchema = z.nativeEnum(ResultsStatus);

/**
 * Enumeration for contest decision algorithm or rules in the Contest element.
 */
export enum VoteVariation {
  /**
   * When voter can select as many candidates as desired in a contest up to a maximum number.
   */
  Approval = 'approval',

  /**
   * For the Borda count voting.
   */
  Borda = 'borda',

  /**
   * When voter can allocate more than one vote to a given candidate.
   */
  Cumulative = 'cumulative',

  /**
   * For majority voting.
   */
  Majority = 'majority',

  /**
   * Includes vote for 1, i.e., 1-of-m.
   */
  NOfM = 'n-of-m',

  /**
   * Used when the vote variation type is not included in this enumeration.
   */
  Other = 'other',

  /**
   * For plurality voting.
   */
  Plurality = 'plurality',

  /**
   * For proportional voting.
   */
  Proportional = 'proportional',

  /**
   * For range voting.
   */
  Range = 'range',

  /**
   * For ranked choice voting.
   */
  Rcv = 'rcv',

  /**
   * For super majority voting.
   */
  SuperMajority = 'super-majority',
}

/**
 * Schema for {@link VoteVariation}.
 */
export const VoteVariationSchema = z.nativeEnum(VoteVariation);

/**
 * Used as a type for character strings; it adds a 32-character annotation to a character string.
 */
export interface AnnotatedString {
  readonly '@type': 'ElectionResults.AnnotatedString';

  /**
   * An annotation of up to 32 characters associated with a character string.
   */
  readonly Annotation?: ShortString;

  readonly Content: string;
}

/**
 * Schema for {@link AnnotatedString}.
 */
export const AnnotatedStringSchema: z.ZodSchema<AnnotatedString> = z.object({
  '@type': z.literal('ElectionResults.AnnotatedString'),
  Annotation: z.optional(z.lazy(/* istanbul ignore next */ () => ShortStringSchema)),
  Content: z.string(),
});

/**
 * Used as a type for character strings that represent Uniform Resource Identifiers (URI); it adds a 32-character annotation to a character string.
 */
export interface AnnotatedUri {
  readonly '@type': 'ElectionResults.AnnotatedUri';

  /**
   * An annotation of up to 32 characters associated with a character string.
   */
  readonly Annotation?: ShortString;

  readonly Content: Uri;
}

/**
 * Schema for {@link AnnotatedUri}.
 */
export const AnnotatedUriSchema: z.ZodSchema<AnnotatedUri> = z.object({
  '@type': z.literal('ElectionResults.AnnotatedUri'),
  Annotation: z.optional(z.lazy(/* istanbul ignore next */ () => ShortStringSchema)),
  Content: UriSchema,
});

/**
 * Used for identifying various ballot counts. It inherits the attributes of Counts.
 */
export interface BallotCounts {
  readonly '@type': 'ElectionResults.BallotCounts';

  /**
   * Number of ballots cast.
   */
  readonly BallotsCast?: integer;

  /**
   * Number of ballots not yet counted.
   */
  readonly BallotsOutstanding?: integer;

  /**
   * Number of ballots rejected.
   */
  readonly BallotsRejected?: integer;

  /**
   * For filtering counts by device type.
   */
  readonly DeviceClass?: DeviceClass;

  /**
   * For filtering counts by political geography or device or device type.
   */
  readonly GpUnitId: string;

  /**
   * Boolean to indicate if votes are suppressed for voter privacy, e.g., true or false. Assumed to be false if not present.
   */
  readonly IsSuppressedForPrivacy?: boolean;

  /**
   * Used when Type is other.
   */
  readonly OtherType?: string;

  /**
   * An identification of the RCV round being reported.
   */
  readonly Round?: integer;

  /**
   * The type of count being used as a filter on the vote counts, e.g., election day, early voting, etc.
   */
  readonly Type: CountItemType;
}

/**
 * Schema for {@link BallotCounts}.
 */
export const BallotCountsSchema: z.ZodSchema<BallotCounts> = z.object({
  '@type': z.literal('ElectionResults.BallotCounts'),
  BallotsCast: z.optional(integerSchema),
  BallotsOutstanding: z.optional(integerSchema),
  BallotsRejected: z.optional(integerSchema),
  DeviceClass: z.optional(z.lazy(/* istanbul ignore next */ () => DeviceClassSchema)),
  GpUnitId: z.string(),
  IsSuppressedForPrivacy: z.optional(z.boolean()),
  OtherType: z.optional(z.string()),
  Round: z.optional(integerSchema),
  Type: z.lazy(/* istanbul ignore next */ () => CountItemTypeSchema),
});

/**
 * For ballot measure (i.e., referenda or a tax measure) and judicial retention contests. It inherits the attributes of Contest.
 * 
 * If the type of ballot measure is not listed in enumeration BallotMeasureType, use other and include the type (that is not listed in the enumeration) in OtherType.
 */
export interface BallotMeasureContest {
  readonly '@id': string;

  readonly '@type': 'ElectionResults.BallotMeasureContest';

  /**
   * Abbreviation for the contest.
   */
  readonly Abbreviation?: string;

  /**
   * Subtitle of the contest as it appears on the ballot.
   */
  readonly BallotSubTitle?: InternationalizedText;

  /**
   * Title of the contest as it appears on the ballot.
   */
  readonly BallotTitle?: InternationalizedText;

  /**
   * For a statement on the ballot associated with a “no” vote.
   */
  readonly ConStatement?: InternationalizedText;

  /**
   * For associating a contest selection for the contest, i.e., a candidate, a ballot measure.
   */
  readonly ContestSelection?: ReadonlyArray<PartySelection | BallotMeasureSelection | CandidateSelection>;

  /**
   * For providing various counting status associated with the contest.
   */
  readonly CountStatus?: readonly CountStatus[];

  /**
   * For a statement on the ballot detailing the effect of abstaining from voting on the ballot measure.
   */
  readonly EffectOfAbstain?: InternationalizedText;

  /**
   * Link to a GpUnit instance. For associating the contest with a reporting unit that represents the geographical scope of the contest, e.g., a district, etc.
   */
  readonly ElectionDistrictId: string;

  /**
   * For associating an ID with the contest.
   */
  readonly ExternalIdentifier?: readonly ExternalIdentifier[];

  /**
   * For full text on the ballot of the ballot measure.
   */
  readonly FullText?: InternationalizedText;

  /**
   * Boolean to indicate whether the selections in the contest are rotated. Assumed to be “no” if not present.
   */
  readonly HasRotation?: boolean;

  /**
   * For associating a URI with the ballot measure contest.
   */
  readonly InfoUri?: readonly AnnotatedUri[];

  /**
   * Name of the contest, not necessarily as it appears on the ballot.
   */
  readonly Name: string;

  /**
   * For associating counts such as overvote and undervotes with the contest.
   */
  readonly OtherCounts?: readonly OtherCounts[];

  /**
   * Used when BallotMeasureType is other.
   */
  readonly OtherType?: string;

  /**
   * For use when VoteVariation is other.
   */
  readonly OtherVoteVariation?: string;

  /**
   * For a statement on the ballot of the number or percentage of votes needed to approve or pass the ballot measure.
   */
  readonly PassageThreshold?: InternationalizedText;

  /**
   * For a statement on the ballot associated with a “yes” vote.
   */
  readonly ProStatement?: InternationalizedText;

  /**
   * Orderering for listing the contest for purposes of results display.  If not present, no order is assumed.
   */
  readonly SequenceOrder?: integer;

  /**
   * Number of subunits, e.g., precincts, that have completed reporting votes for this contest.
   */
  readonly SubUnitsReported?: integer;

  /**
   * For a summary on the ballot of the ballot measure.
   */
  readonly SummaryText?: InternationalizedText;

  /**
   * Total number of subunits, e.g., precincts that have this contest on the ballot.
   */
  readonly TotalSubUnits?: integer;

  /**
   * For indicating the type of ballot measure.
   */
  readonly Type?: BallotMeasureType;

  /**
   * Vote variation associated with the contest, e.g., n-of-m.
   */
  readonly VoteVariation?: VoteVariation;
}

/**
 * Schema for {@link BallotMeasureContest}.
 */
export const BallotMeasureContestSchema: z.ZodSchema<BallotMeasureContest> = z.object({
  '@id': z.string(),
  '@type': z.literal('ElectionResults.BallotMeasureContest'),
  Abbreviation: z.optional(z.string()),
  BallotSubTitle: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
  BallotTitle: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
  ConStatement: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
  ContestSelection: z.optional(z.array(z.union([z.lazy(/* istanbul ignore next */ () => PartySelectionSchema), z.lazy(/* istanbul ignore next */ () => BallotMeasureSelectionSchema), z.lazy(/* istanbul ignore next */ () => CandidateSelectionSchema)]))),
  CountStatus: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => CountStatusSchema))),
  EffectOfAbstain: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
  ElectionDistrictId: z.string(),
  ExternalIdentifier: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => ExternalIdentifierSchema))),
  FullText: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
  HasRotation: z.optional(z.boolean()),
  InfoUri: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => AnnotatedUriSchema))),
  Name: z.string(),
  OtherCounts: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => OtherCountsSchema))),
  OtherType: z.optional(z.string()),
  OtherVoteVariation: z.optional(z.string()),
  PassageThreshold: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
  ProStatement: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
  SequenceOrder: z.optional(integerSchema),
  SubUnitsReported: z.optional(integerSchema),
  SummaryText: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
  TotalSubUnits: z.optional(integerSchema),
  Type: z.optional(z.lazy(/* istanbul ignore next */ () => BallotMeasureTypeSchema)),
  VoteVariation: z.optional(z.lazy(/* istanbul ignore next */ () => VoteVariationSchema)),
});

/**
 * For a contest selection in a ballot measure contest. Because judicial or other retention contests are often treated like ballot measure contests, this element can be used also for retention contests. It inherits the attributes of ContestSelection.
 */
export interface BallotMeasureSelection {
  readonly '@id': string;

  readonly '@type': 'ElectionResults.BallotMeasureSelection';

  /**
   * For associating an ID with the ballot measure selection.
   */
  readonly ExternalIdentifier?: readonly ExternalIdentifier[];

  /**
   * Contains the text used to indicate a vote for or against the ballot measure, e.g., “yes”, “no”.
   */
  readonly Selection: InternationalizedText;

  /**
   * Order in which the candidate is listed on the ballot for purposes of results display. If not present, no order is assumed.
   */
  readonly SequenceOrder?: integer;

  /**
   * For associating the contest selection’s vote counts.
   */
  readonly VoteCounts?: readonly VoteCounts[];
}

/**
 * Schema for {@link BallotMeasureSelection}.
 */
export const BallotMeasureSelectionSchema: z.ZodSchema<BallotMeasureSelection> = z.object({
  '@id': z.string(),
  '@type': z.literal('ElectionResults.BallotMeasureSelection'),
  ExternalIdentifier: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => ExternalIdentifierSchema))),
  Selection: z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema),
  SequenceOrder: z.optional(integerSchema),
  VoteCounts: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => VoteCountsSchema))),
});

/**
 * For defining a ballot style composed of ordered content (i.e. Headers or Contests) and their contest selections, and associating the ballot style with a political party, a reference to an image of the ballot, and a reference to a precinct or other geopolitical unit that the ballot is unique to. Election includes BallotStyle.BallotStyle references OrderedContent to include content that appears on that ballot style. To preserve any rotation associated with the ballot, it is expected that the generating application will list the occurrences of OrderedContest in the order as on the ballot for the associated geopolitical unit.BallotStyle references one or more GpUnit instances defined for the associated precincts or split precincts. If the ballot style is associated with multiple precincts (or other geographies), multiple references to the precinct GpUnit instances can be included.
 */
export interface BallotStyle {
  readonly '@type': 'ElectionResults.BallotStyle';

  /**
   * For associating an ID with the ballot style.
   */
  readonly ExternalIdentifier?: readonly ExternalIdentifier[];

  /**
   * Unique identifier for one or more GpUnit instances.  For associating specific geopolitical units with the ballot style.
   */
  readonly GpUnitIds: readonly string[];

  /**
   * URI for a ballot image.
   */
  readonly ImageUri?: readonly AnnotatedUri[];

  /**
   * For associating a ballot style with ballot content, such as contests or headers.
   */
  readonly OrderedContent?: ReadonlyArray<OrderedContest | OrderedHeader>;

  /**
   * Unique identifier for one or more Party instances.  For associating one or more parties with the ballot style.
   */
  readonly PartyIds?: readonly string[];
}

/**
 * Schema for {@link BallotStyle}.
 */
export const BallotStyleSchema: z.ZodSchema<BallotStyle> = z.object({
  '@type': z.literal('ElectionResults.BallotStyle'),
  ExternalIdentifier: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => ExternalIdentifierSchema))),
  GpUnitIds: z.array(z.string()).min(1),
  ImageUri: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => AnnotatedUriSchema))),
  OrderedContent: z.optional(z.array(z.union([z.lazy(/* istanbul ignore next */ () => OrderedContestSchema), z.lazy(/* istanbul ignore next */ () => OrderedHeaderSchema)]))),
  PartyIds: z.optional(z.array(z.string())),
});

/**
 * For defining information about a candidate in a contest. CandidateSelection references Candidate instances to associate one or more candidates with a contest selection. Election includes Candidate.
 * 
 * Candidate uses the Party association to reference the candidate's political party. If the candidate is endorsed by other parties for a particular contest, the endorsing parties are referenced using the CandidateSelection attribute.
 * 
 * ExternalIdentifier can be used to associate an ID with the candidate. If the type is not listed in enumeration IdentifierType, use other and include the type (that is not listed in the enumeration) in OtherType.
 */
export interface Candidate {
  readonly '@id': string;

  readonly '@type': 'ElectionResults.Candidate';

  /**
   * For the candidate’s name as listed on the ballot.
   */
  readonly BallotName: InternationalizedText;

  /**
   * The slogan or motto used by the candidate in their campaign.
   */
  readonly CampaignSlogan?: InternationalizedText;

  /**
   * For associating contact information for the candidate.
   */
  readonly ContactInformation?: ContactInformation;

  /**
   * For associating codes with the candidate.
   */
  readonly ExternalIdentifier?: readonly ExternalIdentifier[];

  /**
   * Date when the candidate filed for the contest.
   */
  readonly FileDate?: Date;

  /**
   * Boolean to indicate whether the candidate is the incumbent for the office associated with the contest. Assumed to be “no” if not present.
   */
  readonly IsIncumbent?: boolean;

  /**
   * Boolean to indicate whether the candidate is the top of a ticket that includes multiple candidates. Assumed to be “no” if not present.
   */
  readonly IsTopTicket?: boolean;

  /**
   * For associating a party with the candidate.
   */
  readonly PartyId?: string;

  /**
   * For associating more detailed information about the candidate.
   */
  readonly PersonId?: string;

  /**
   * Final status of the candidate, e.g., winner, withdrawn, etc.
   */
  readonly PostElectionStatus?: CandidatePostElectionStatus;

  /**
   * Registration status of the candidate, e.g., filed, qualified, etc.
   */
  readonly PreElectionStatus?: CandidatePreElectionStatus;
}

/**
 * Schema for {@link Candidate}.
 */
export const CandidateSchema: z.ZodSchema<Candidate> = z.object({
  '@id': z.string(),
  '@type': z.literal('ElectionResults.Candidate'),
  BallotName: z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema),
  CampaignSlogan: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
  ContactInformation: z.optional(z.lazy(/* istanbul ignore next */ () => ContactInformationSchema)),
  ExternalIdentifier: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => ExternalIdentifierSchema))),
  FileDate: z.optional(DateSchema),
  IsIncumbent: z.optional(z.boolean()),
  IsTopTicket: z.optional(z.boolean()),
  PartyId: z.optional(z.string()),
  PersonId: z.optional(z.string()),
  PostElectionStatus: z.optional(z.lazy(/* istanbul ignore next */ () => CandidatePostElectionStatusSchema)),
  PreElectionStatus: z.optional(z.lazy(/* istanbul ignore next */ () => CandidatePreElectionStatusSchema)),
});

/**
 * For a contest that involves selecting one or more candidates. It inherits the attributes of Contest.
 * 
 * This class optionally references Office and Party. If the candidate contest is associated with a ticket (of candidates) and each candidate in the ticket is associated with a separate office, the association to Office can reference each of the separate offices. For example, if the contest is for the state governor ticket but Governor and Lieutenant (Lt.) Governor are both separate offices, the association references first to the Office instance defined for the Governor's office and then to the Lt. Governor's office. In this case, it is expected that the generating application will list the multiple references according to a jurisdiction-defined ordering scheme, e.g., Governor first and Lt. Governor second.
 * 
 * Note that when using the CandidateSelection class to associate the candidates with a contest selection for the contest, the order of the candidates should match the order of offices. Again, using the example of the state governor ticket, if the offices are listed with Governor first and Lt. Governor second, then the order of the candidates in the ContestSelection instance should be identical, with the Governor candidate first and the Lt. Governor candidate second.
 */
export interface CandidateContest {
  readonly '@id': string;

  readonly '@type': 'ElectionResults.CandidateContest';

  /**
   * Abbreviation for the contest.
   */
  readonly Abbreviation?: string;

  /**
   * Subtitle of the contest as it appears on the ballot.
   */
  readonly BallotSubTitle?: InternationalizedText;

  /**
   * Title of the contest as it appears on the ballot.
   */
  readonly BallotTitle?: InternationalizedText;

  /**
   * For associating a contest selection for the contest, i.e., a candidate, a ballot measure.
   */
  readonly ContestSelection?: ReadonlyArray<PartySelection | BallotMeasureSelection | CandidateSelection>;

  /**
   * For providing various counting status associated with the contest.
   */
  readonly CountStatus?: readonly CountStatus[];

  /**
   * Link to a GpUnit instance. For associating the contest with a reporting unit that represents the geographical scope of the contest, e.g., a district, etc.
   */
  readonly ElectionDistrictId: string;

  /**
   * For associating an ID with the contest.
   */
  readonly ExternalIdentifier?: readonly ExternalIdentifier[];

  /**
   * Boolean to indicate whether the selections in the contest are rotated. Assumed to be “no” if not present.
   */
  readonly HasRotation?: boolean;

  /**
   * Name of the contest, not necessarily as it appears on the ballot.
   */
  readonly Name: string;

  /**
   * Number of candidates that are elected in the contest (“n” of n-of-m).
   */
  readonly NumberElected?: integer;

  /**
   * The number of candidates in a runoff contest.
   */
  readonly NumberRunoff?: integer;

  /**
   * For associating office descriptions.
   */
  readonly OfficeIds?: readonly string[];

  /**
   * For associating counts such as overvote and undervotes with the contest.
   */
  readonly OtherCounts?: readonly OtherCounts[];

  /**
   * For use when VoteVariation is other.
   */
  readonly OtherVoteVariation?: string;

  /**
   * For associating parties with the contest.
   */
  readonly PrimaryPartyIds?: readonly string[];

  /**
   * Orderering for listing the contest for purposes of results display.  If not present, no order is assumed.
   */
  readonly SequenceOrder?: integer;

  /**
   * Number of subunits, e.g., precincts, that have completed reporting votes for this contest.
   */
  readonly SubUnitsReported?: integer;

  /**
   * Total number of subunits, e.g., precincts that have this contest on the ballot.
   */
  readonly TotalSubUnits?: integer;

  /**
   * Vote variation associated with the contest, e.g., n-of-m.
   */
  readonly VoteVariation?: VoteVariation;

  /**
   * Maximum number of votes per voter in this contest.
   */
  readonly VotesAllowed: integer;
}

/**
 * Schema for {@link CandidateContest}.
 */
export const CandidateContestSchema: z.ZodSchema<CandidateContest> = z.object({
  '@id': z.string(),
  '@type': z.literal('ElectionResults.CandidateContest'),
  Abbreviation: z.optional(z.string()),
  BallotSubTitle: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
  BallotTitle: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
  ContestSelection: z.optional(z.array(z.union([z.lazy(/* istanbul ignore next */ () => PartySelectionSchema), z.lazy(/* istanbul ignore next */ () => BallotMeasureSelectionSchema), z.lazy(/* istanbul ignore next */ () => CandidateSelectionSchema)]))),
  CountStatus: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => CountStatusSchema))),
  ElectionDistrictId: z.string(),
  ExternalIdentifier: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => ExternalIdentifierSchema))),
  HasRotation: z.optional(z.boolean()),
  Name: z.string(),
  NumberElected: z.optional(integerSchema),
  NumberRunoff: z.optional(integerSchema),
  OfficeIds: z.optional(z.array(z.string())),
  OtherCounts: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => OtherCountsSchema))),
  OtherVoteVariation: z.optional(z.string()),
  PrimaryPartyIds: z.optional(z.array(z.string())),
  SequenceOrder: z.optional(integerSchema),
  SubUnitsReported: z.optional(integerSchema),
  TotalSubUnits: z.optional(integerSchema),
  VoteVariation: z.optional(z.lazy(/* istanbul ignore next */ () => VoteVariationSchema)),
  VotesAllowed: integerSchema,
});

/**
 * For the contest selections in a candidate contest, including for write-ins. It inherits the attributes of ContestSelection. References to multiple Candidate instances can be included if necessary, e.g., when the contest selection would be for a ticket of candidates (unless the ticket itself is defined as a candidate).
 * 
 * EndorsementParty is used to reference any associated endorsement parties other than the specific party of the candidate (Candidate references Party for that purpose). For example, if a candidate of one party is also endorsed by a second party, use EndorsementParty to reference the second party. A second example would be for ballot fusion as used in some states, where the same candidate is listed multiple times in the same contest, but with different endorsement parties.
 * 
 * When multiple candidates are referenced for a ticket and the ordering of the candidates is important to preserve, it is expected that the generating application will list the references to Candidate instances according to the ordering scheme in place. For example, if the contest is for a ticket in which each candidate is associated with a different office, then the order of the candidates should match the same ordering of the &lt;Office&gt; element references within &lt;OfficeIds&gt; in the &lt;Contest xsi:type=&quot;CandidateContest&quot; ... /&gt; element.
 */
export interface CandidateSelection {
  readonly '@id': string;

  readonly '@type': 'ElectionResults.CandidateSelection';

  /**
   * For associating a candidate with the candidate selection on the ballot and for cases where the contest selection is for multiple candidates, e.g., a ticket.
   */
  readonly CandidateIds?: readonly string[];

  /**
   * For associating one or more endorsing parties with the candidate selection.
   */
  readonly EndorsementPartyIds?: readonly string[];

  /**
   * Indicates whether the candidate is a write-in, e.g., true or false.  Assumed to be false if not present.
   */
  readonly IsWriteIn?: boolean;

  /**
   * Order in which the candidate is listed on the ballot for purposes of results display. If not present, no order is assumed.
   */
  readonly SequenceOrder?: integer;

  /**
   * For associating the contest selection’s vote counts.
   */
  readonly VoteCounts?: readonly VoteCounts[];
}

/**
 * Schema for {@link CandidateSelection}.
 */
export const CandidateSelectionSchema: z.ZodSchema<CandidateSelection> = z.object({
  '@id': z.string(),
  '@type': z.literal('ElectionResults.CandidateSelection'),
  CandidateIds: z.optional(z.array(z.string())),
  EndorsementPartyIds: z.optional(z.array(z.string())),
  IsWriteIn: z.optional(z.boolean()),
  SequenceOrder: z.optional(integerSchema),
  VoteCounts: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => VoteCountsSchema))),
});

/**
 * For defining a coalition, i.e., a collection of parties organized for the purpose of endorsing a candidate in a contest. It inherits the attributes and elements of Party.
 * 
 * Coalition instances themselves are composed of multiple Party references along with a reference to an associated Contests.
 * 
 * If there are no associated Contests, a general default is that the coalition endorses the associated parties.
 */
export interface Coalition {
  readonly '@id': string;

  readonly '@type': 'ElectionResults.Coalition';

  /**
   * Short name for the party, e.g., “DEM”.
   */
  readonly Abbreviation?: InternationalizedText;

  /**
   * For associating an HTML RGB color coding with the party.
   */
  readonly Color?: HtmlColorString;

  /**
   * For associating contact information regarding the party, e.g., party offices.
   */
  readonly ContactInformation?: ContactInformation;

  /**
   * For associating contests with the coalition.
   */
  readonly ContestIds?: readonly string[];

  /**
   * For associating an ID with the party.
   */
  readonly ExternalIdentifier?: readonly ExternalIdentifier[];

  /**
   * For indicating whether the party is recognized by the election authority; “false” is assumed if not present.
   */
  readonly IsRecognizedParty?: boolean;

  /**
   * Identification of a Party's leader.
   */
  readonly LeaderPersonIds?: readonly string[];

  /**
   * A URI to the party’s graphical logo.
   */
  readonly LogoUri?: readonly AnnotatedUri[];

  /**
   * Official full name of the party, e.g., “Republican”; can appear on the ballot.
   */
  readonly Name: InternationalizedText;

  /**
   * For associating parties with the coalition.
   */
  readonly PartyIds?: readonly string[];

  /**
   * The GpUnit(s) the party operates in or the top-most GpUnit.
   */
  readonly PartyScopeGpUnitIds?: readonly string[];

  /**
   * The slogan or motto used by a political party.
   */
  readonly Slogan?: InternationalizedText;
}

/**
 * Schema for {@link Coalition}.
 */
export const CoalitionSchema: z.ZodSchema<Coalition> = z.object({
  '@id': z.string(),
  '@type': z.literal('ElectionResults.Coalition'),
  Abbreviation: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
  Color: z.optional(z.lazy(/* istanbul ignore next */ () => HtmlColorStringSchema)),
  ContactInformation: z.optional(z.lazy(/* istanbul ignore next */ () => ContactInformationSchema)),
  ContestIds: z.optional(z.array(z.string())),
  ExternalIdentifier: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => ExternalIdentifierSchema))),
  IsRecognizedParty: z.optional(z.boolean()),
  LeaderPersonIds: z.optional(z.array(z.string())),
  LogoUri: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => AnnotatedUriSchema))),
  Name: z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema),
  PartyIds: z.optional(z.array(z.string())),
  PartyScopeGpUnitIds: z.optional(z.array(z.string())),
  Slogan: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
});

/**
 * For defining contact information about objects such as persons, boards of authorities, organizations, etc. Election, ElectionAdministration, Person, GpUnit, and Office include ContactInformation.
 * 
 * To include an address for the contact, use multiple occurrences of AddressLine. It is expected that the generating application will list the name of the person/organization in the first occurrence of AddressLine, with subsequent ordered occurrences for street address, city, state, zip code, etc. Directions can be used to supply any additional address-related information that may appear in multiple languages.
 * 
 * ContactInformation includes LatLng so as to associate latitude/longitude with the contact address.
 * 
 * Email, Fax, and Phone are of type AnnotatedString, which permits up to a 32-character annotation to be associated with the data.
 */
export interface ContactInformation {
  readonly '@type': 'ElectionResults.ContactInformation';

  /**
   * For associating an address with the contact.
   */
  readonly AddressLine?: readonly string[];

  /**
   * Directional information in addition to address information.
   */
  readonly Directions?: InternationalizedText;

  /**
   * Email address associated with the contact.
   */
  readonly Email?: readonly AnnotatedString[];

  /**
   * Fax number associated with the contact.
   */
  readonly Fax?: readonly AnnotatedString[];

  /**
   * For use as needed and compatibility with the VIP schema.
   */
  readonly Label?: string;

  /**
   * For latitude and longitude information associated with the contact.
   */
  readonly LatLng?: LatLng;

  /**
   * Name associated with the contact.
   */
  readonly Name?: string;

  /**
   * Phone number associated with the contact.
   */
  readonly Phone?: readonly AnnotatedString[];

  /**
   * For associating a schedule with the contact.
   */
  readonly Schedule?: readonly Schedule[];

  /**
   * URI associated with the contact.
   */
  readonly Uri?: readonly AnnotatedUri[];
}

/**
 * Schema for {@link ContactInformation}.
 */
export const ContactInformationSchema: z.ZodSchema<ContactInformation> = z.object({
  '@type': z.literal('ElectionResults.ContactInformation'),
  AddressLine: z.optional(z.array(z.string())),
  Directions: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
  Email: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => AnnotatedStringSchema))),
  Fax: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => AnnotatedStringSchema))),
  Label: z.optional(z.string()),
  LatLng: z.optional(z.lazy(/* istanbul ignore next */ () => LatLngSchema)),
  Name: z.optional(z.string()),
  Phone: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => AnnotatedStringSchema))),
  Schedule: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => ScheduleSchema))),
  Uri: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => AnnotatedUriSchema))),
});

/**
 * For reporting on the counting status for various items such as ballot types or write-ins, e.g., whether for a certain type of ballot, the counts are in progress, not yet started, complete, etc. Contest, Election, and GpUnit include CountStatus.
 * 
 * If the type of count item is not listed in enumeration CountItemType, use other and include the type (that is not listed in the enumeration) in OtherType.
 */
export interface CountStatus {
  readonly '@type': 'ElectionResults.CountStatus';

  /**
   * Used when Type is other.
   */
  readonly OtherType?: string;

  /**
   * The status of the count, from the CountItemStatus enumeration.
   */
  readonly Status: CountItemStatus;

  /**
   * The type of item, from the CountItemType enumeration.
   */
  readonly Type: CountItemType;
}

/**
 * Schema for {@link CountStatus}.
 */
export const CountStatusSchema: z.ZodSchema<CountStatus> = z.object({
  '@type': z.literal('ElectionResults.CountStatus'),
  OtherType: z.optional(z.string()),
  Status: z.lazy(/* istanbul ignore next */ () => CountItemStatusSchema),
  Type: z.lazy(/* istanbul ignore next */ () => CountItemTypeSchema),
});

/**
 * For filtering vote counts by device-related information. GpUnit, Counts, and OtherCounts include DeviceClass.
 */
export interface DeviceClass {
  readonly '@type': 'ElectionResults.DeviceClass';

  /**
   * Manufacturer of the device.
   */
  readonly Manufacturer?: string;

  /**
   * Manufacturer’s device model, used to filter on, e.g., a specific model of DRE or other device type.
   */
  readonly Model?: string;

  /**
   * Used when Type is other.
   */
  readonly OtherType?: string;

  /**
   * Enumerated type of device, e.g., "dre", "opscan-precinct", etc.
   */
  readonly Type?: DeviceType;
}

/**
 * Schema for {@link DeviceClass}.
 */
export const DeviceClassSchema: z.ZodSchema<DeviceClass> = z.object({
  '@type': z.literal('ElectionResults.DeviceClass'),
  Manufacturer: z.optional(z.string()),
  Model: z.optional(z.string()),
  OtherType: z.optional(z.string()),
  Type: z.optional(z.lazy(/* istanbul ignore next */ () => DeviceTypeSchema)),
});

/**
 * For defining the status of the election and associated information such as candidates, contests, and vote counts.
 * 
 * Election includes links to the major instances that are specific to an election: BallotStyle, Candidate, and Contest.
 * 
 * Election includes a required association end ElectionScope, which links to a GpUnit instance for the purpose of identifying the geographical scope of the election. For example, for an election within a county, ElectionScope would reference a GpUnit defined for the county. If it is desired to include election authority information, the GpUnit can include ElectionAdministration.
 */
export interface Election {
  readonly '@type': 'ElectionResults.Election';

  /**
   * Used for identifying various ballot counts.
   */
  readonly BallotCounts?: readonly BallotCounts[];

  /**
   * For defining ballot styles associated with the election.
   */
  readonly BallotStyle?: readonly BallotStyle[];

  /**
   * For defining candidates associated with the election.
   */
  readonly Candidate?: readonly Candidate[];

  /**
   * For associating various contact information with the election.
   */
  readonly ContactInformation?: ContactInformation;

  /**
   * For defining contests associated with the election.
   */
  readonly Contest?: ReadonlyArray<PartyContest | BallotMeasureContest | CandidateContest | RetentionContest>;

  /**
   * For providing various counting status on types of ballots or other items.
   */
  readonly CountStatus?: readonly CountStatus[];

  /**
   * Unique identifier for a GpUnit element. For associating the election with a reporting unit that represents the geographical scope of the election, e.g., a state, a county, etc.
   */
  readonly ElectionScopeId: string;

  /**
   * Calendar end date of the election; for a typical one-day election, the end date is the same as the start date.
   */
  readonly EndDate: Date;

  /**
   * For associating an ID with the election.
   */
  readonly ExternalIdentifier?: readonly ExternalIdentifier[];

  /**
   * For including a name for the election; the name could be the same name as appears on the ballot.
   */
  readonly Name: InternationalizedText;

  /**
   * Used when Type is other.
   */
  readonly OtherType?: string;

  /**
   * Calendar start date of the election, e.g., “2018-11-04”.
   */
  readonly StartDate: Date;

  /**
   * Enumerated type of election, e.g., partisan-primary, open-primary, etc.
   */
  readonly Type: ElectionType;
}

/**
 * Schema for {@link Election}.
 */
export const ElectionSchema: z.ZodSchema<Election> = z.object({
  '@type': z.literal('ElectionResults.Election'),
  BallotCounts: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => BallotCountsSchema))),
  BallotStyle: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => BallotStyleSchema))),
  Candidate: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => CandidateSchema))),
  ContactInformation: z.optional(z.lazy(/* istanbul ignore next */ () => ContactInformationSchema)),
  Contest: z.optional(z.array(z.union([z.lazy(/* istanbul ignore next */ () => PartyContestSchema), z.lazy(/* istanbul ignore next */ () => BallotMeasureContestSchema), z.lazy(/* istanbul ignore next */ () => CandidateContestSchema), z.lazy(/* istanbul ignore next */ () => RetentionContestSchema)]))),
  CountStatus: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => CountStatusSchema))),
  ElectionScopeId: z.string(),
  EndDate: DateSchema,
  ExternalIdentifier: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => ExternalIdentifierSchema))),
  Name: z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema),
  OtherType: z.optional(z.string()),
  StartDate: DateSchema,
  Type: z.lazy(/* istanbul ignore next */ () => ElectionTypeSchema),
});

/**
 * Used to provide various information about an election authority. ReportingUnit includes ElectionAdministration.
 * 
 * ElectionAdministration includes ContactInformation for the election authority and, using ElectionOfficialPerson references one or more Person instances defined for individuals/organizations associated with the election authority.
 */
export interface ElectionAdministration {
  readonly '@type': 'ElectionResults.ElectionAdministration';

  /**
   * For including various contact information.
   */
  readonly ContactInformation?: ContactInformation;

  /**
   * Unique identifier for one or more Person elements defined for the election authority.
   */
  readonly ElectionOfficialPersonIds?: readonly string[];

  /**
   * Name of the election authority.
   */
  readonly Name?: string;
}

/**
 * Schema for {@link ElectionAdministration}.
 */
export const ElectionAdministrationSchema: z.ZodSchema<ElectionAdministration> = z.object({
  '@type': z.literal('ElectionResults.ElectionAdministration'),
  ContactInformation: z.optional(z.lazy(/* istanbul ignore next */ () => ContactInformationSchema)),
  ElectionOfficialPersonIds: z.optional(z.array(z.string())),
  Name: z.optional(z.string()),
});

/**
 * For defining items pertaining to the status and format of the report and when it was generated.
 * 
 * ElectionReport references the major elements that are not necessarily specific to an election and that therefore can exist in a pre-election report: GpUnit, Office and OfficeGroup, Party, Person, and Election.
 */
export interface ElectionReport {
  readonly '@type': 'ElectionResults.ElectionReport';

  /**
   * For associating elections with the report.
   */
  readonly Election?: readonly Election[];

  /**
   * For associating an ID with the report.
   */
  readonly ExternalIdentifier?: readonly ExternalIdentifier[];

  /**
   * Detail level of the report, e.g., contest summary, precinct level results, etc.
   */
  readonly Format: ReportDetailLevel;

  /**
   * Identifies the date and time that the election report was generated.
   */
  readonly GeneratedDate: DateTimeWithZone;

  /**
   * For associating geopolitical units with the report.
   */
  readonly GpUnit?: ReadonlyArray<ReportingDevice | ReportingUnit>;

  /**
   * For associating headers with parts of a ballot style.
   */
  readonly Header?: readonly Header[];

  /**
   * Used to indicate whether the report is a test report. Assumed to be “false” if not present.
   */
  readonly IsTest?: boolean;

  /**
   * Identification of the report issuer.
   */
  readonly Issuer: string;

  /**
   * An abbreviation of the report issuer such as the 2-character U.S. Census Bureau abbreviation of the state whose results are being reported, e.g., AL, TX, MN, etc.
   */
  readonly IssuerAbbreviation: string;

  /**
   * For including an arbitrary message with the report.
   */
  readonly Notes?: string;

  /**
   * For associating offices with the report.
   */
  readonly Office?: readonly Office[];

  /**
   * For associating a name for a grouping of offices with the report.
   */
  readonly OfficeGroup?: readonly OfficeGroup[];

  /**
   * For associating parties with the report.
   */
  readonly Party?: ReadonlyArray<Party | Coalition>;

  /**
   * For associating persons with the report.
   */
  readonly Person?: readonly Person[];

  /**
   * The upper bound of the sequence; e.g., “1” if there is only 1 report, “2” if there are two reports in the sequence, etc.
   */
  readonly SequenceEnd: integer;

  /**
   * The report’s number as part of a sequence of reports, used with  so as to be read as, e.g., 1 of 1, 1 of 2, 2 of 2, etc.  Starts with “1”.
   */
  readonly SequenceStart: integer;

  /**
   * Status of the election report, e.g., test mode, unofficial, etc.
   */
  readonly Status: ResultsStatus;

  /**
   * A description of the type of test, e.g., pre-election, logic and accuracy, etc.
   */
  readonly TestType?: string;

  /**
   * An identifier of the vendor application generating the election report, e.g., X-EMS version 3.1.a.
   */
  readonly VendorApplicationId: string;
}

/**
 * Schema for {@link ElectionReport}.
 */
export const ElectionReportSchema: z.ZodSchema<ElectionReport> = z.object({
  '@type': z.literal('ElectionResults.ElectionReport'),
  Election: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => ElectionSchema))),
  ExternalIdentifier: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => ExternalIdentifierSchema))),
  Format: z.lazy(/* istanbul ignore next */ () => ReportDetailLevelSchema),
  GeneratedDate: z.lazy(/* istanbul ignore next */ () => DateTimeWithZoneSchema),
  GpUnit: z.optional(z.array(z.union([z.lazy(/* istanbul ignore next */ () => ReportingDeviceSchema), z.lazy(/* istanbul ignore next */ () => ReportingUnitSchema)]))),
  Header: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => HeaderSchema))),
  IsTest: z.optional(z.boolean()),
  Issuer: z.string(),
  IssuerAbbreviation: z.string(),
  Notes: z.optional(z.string()),
  Office: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => OfficeSchema))),
  OfficeGroup: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => OfficeGroupSchema))),
  Party: z.optional(z.array(z.union([z.lazy(/* istanbul ignore next */ () => PartySchema), z.lazy(/* istanbul ignore next */ () => CoalitionSchema)]))),
  Person: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => PersonSchema))),
  SequenceEnd: integerSchema,
  SequenceStart: integerSchema,
  Status: z.lazy(/* istanbul ignore next */ () => ResultsStatusSchema),
  TestType: z.optional(z.string()),
  VendorApplicationId: z.string(),
});

/**
 * For associating a jurisdiction's codes, i.e., identifiers, with objects such as candidates, offices, or geopolitical units such as counties, towns, precincts, etc. Multiple occurrences of the ExternalIdentifier sub-element can be used to associate multiple codes, e.g., if there is a desire to associate multiple codes with a particular object such as FIPS (Federal Information Processing Standard) codes as well as OCD-IDs (Open Civic Data Identifiers).
 * 
 * For elements that link to ExternalIdentifier instances, if the type is not listed in enumeration IdentifierType, use other and include the type (that is not listed in the enumeration) in OtherType.
 */
export interface ExternalIdentifier {
  readonly '@type': 'ElectionResults.ExternalIdentifier';

  /**
   * For use as needed and compatibility with the VIP schema.
   */
  readonly Label?: string;

  /**
   * Used when IdentifierType value is other.
   */
  readonly OtherType?: string;

  /**
   * An identifier type, e.g., FIPS.
   */
  readonly Type: IdentifierType;

  /**
   * The identifier used by the jurisdiction.
   */
  readonly Value: string;
}

/**
 * Schema for {@link ExternalIdentifier}.
 */
export const ExternalIdentifierSchema: z.ZodSchema<ExternalIdentifier> = z.object({
  '@type': z.literal('ElectionResults.ExternalIdentifier'),
  Label: z.optional(z.string()),
  OtherType: z.optional(z.string()),
  Type: z.lazy(/* istanbul ignore next */ () => IdentifierTypeSchema),
  Value: z.string(),
});

/**
 * For defining a reusable set of headers.
 */
export interface Header {
  readonly '@id': string;

  readonly '@type': 'ElectionResults.Header';

  /**
   * For associating an ID with the header.
   */
  readonly ExternalIdentifier?: readonly ExternalIdentifier[];

  /**
   * Name of the header, as it is to appear on a ballot style.
   */
  readonly Name: InternationalizedText;
}

/**
 * Schema for {@link Header}.
 */
export const HeaderSchema: z.ZodSchema<Header> = z.object({
  '@id': z.string(),
  '@type': z.literal('ElectionResults.Header'),
  ExternalIdentifier: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => ExternalIdentifierSchema))),
  Name: z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema),
});

/**
 * Hours is used to specify a specific day and hours on that day, including the time zone.  Multiple occurrences of Hours can be used if the schedule includes a range of days and hours.
 */
export interface Hours {
  readonly '@type': 'ElectionResults.Hours';

  /**
   * Day of the week.
   */
  readonly Day?: DayType;

  /**
   * End time of the schedule.
   */
  readonly EndTime: TimeWithZone;

  /**
   * For use as needed and compatibility with the VIP schema.
   */
  readonly Label?: string;

  /**
   * Start time of the schedule.
   */
  readonly StartTime: TimeWithZone;
}

/**
 * Schema for {@link Hours}.
 */
export const HoursSchema: z.ZodSchema<Hours> = z.object({
  '@type': z.literal('ElectionResults.Hours'),
  Day: z.optional(z.lazy(/* istanbul ignore next */ () => DayTypeSchema)),
  EndTime: z.lazy(/* istanbul ignore next */ () => TimeWithZoneSchema),
  Label: z.optional(z.string()),
  StartTime: z.lazy(/* istanbul ignore next */ () => TimeWithZoneSchema),
});

/**
 * For strings that can contain multi-national text, for use with text as shown on a ballot containing multi-national text. The Identifier attribute can be used to assign an identifier to the text as desired.
 * 
 * Text uses the xsd:language type such that its language attribute must be set to a value that identifies the language.
 * 
 * Values for language are from ISO 639 [12] and include:
 * 
 * en – English
 * 
 * en-US – U.S. English
 * 
 * en-GB – U.K. English
 * 
 * fr – French
 * 
 * es – Spanish
 * 
 * zh – Chinese
 * 
 * ja – Japanese
 * 
 * ko – Korean
 */
export interface InternationalizedText {
  readonly '@type': 'ElectionResults.InternationalizedText';

  /**
   * For use as needed and compatibility with the VIP schema.
   */
  readonly Label?: string;

  /**
   * Used to hold a string of text with an associated table indicating the language used.
   */
  readonly Text: readonly LanguageString[];
}

/**
 * Schema for {@link InternationalizedText}.
 */
export const InternationalizedTextSchema: z.ZodSchema<InternationalizedText> = z.object({
  '@type': z.literal('ElectionResults.InternationalizedText'),
  Label: z.optional(z.string()),
  Text: z.array(z.lazy(/* istanbul ignore next */ () => LanguageStringSchema)).min(1),
});

/**
 * Used to hold a string of text with an associated table indicating the language used.
 */
export interface LanguageString {
  readonly '@type': 'ElectionResults.LanguageString';

  readonly Content: string;

  /**
   * Identification of the language, such as 'es'.
   */
  readonly Language: string;
}

/**
 * Schema for {@link LanguageString}.
 */
export const LanguageStringSchema: z.ZodSchema<LanguageString> = z.object({
  '@type': z.literal('ElectionResults.LanguageString'),
  Content: z.string(),
  Language: z.string(),
});

/**
 * Associates latitude/longitude with a contact address.
 */
export interface LatLng {
  readonly '@type': 'ElectionResults.LatLng';

  /**
   * For use as needed and compatibility with the VIP schema.
   */
  readonly Label?: string;

  /**
   * Latitude of the contact location.
   */
  readonly Latitude: number;

  /**
   * Longitude of the contact location.
   */
  readonly Longitude: number;

  /**
   * System used to perform the lookup from location name to lat/lng, e.g., the name of a geocoding service.
   */
  readonly Source?: string;
}

/**
 * Schema for {@link LatLng}.
 */
export const LatLngSchema: z.ZodSchema<LatLng> = z.object({
  '@type': z.literal('ElectionResults.LatLng'),
  Label: z.optional(z.string()),
  Latitude: z.number(),
  Longitude: z.number(),
  Source: z.optional(z.string()),
});

/**
 * For defining an office and information associated with a contest and/or a district. ElectionReport includes Office. CandidateContest and RetentionContest reference Office.
 * 
 * Office includes Term for defining details about the term of an office such as start/end dates and the type of term. OfficeGroup is included from ElectionReport to assign a name to a grouping of office definitions.
 * 
 * Office includes an optional ElectionDistrict reference to a GpUnit for the purpose of identifying the geographical scope of the office. For example, for an office for a state senate seat, ElectionDistrict would include a reference to the GpUnit defined for the district associated with that office.
 */
export interface Office {
  readonly '@id': string;

  readonly '@type': 'ElectionResults.Office';

  /**
   * For associating various contact information with the office.
   */
  readonly ContactInformation?: ContactInformation;

  /**
   * A description of the office, possibly as shown on the ballot to the voter.
   */
  readonly Description?: InternationalizedText;

  /**
   * Link to a GpUnit instance. For associating the office with a reporting unit that represents the geographical scope of the contest, e.g., a district, etc.
   */
  readonly ElectionDistrictId?: string;

  /**
   * For associating an ID with the office.
   */
  readonly ExternalIdentifier?: readonly ExternalIdentifier[];

  /**
   * Date and time when a candidate must have filed for the contest for the office.
   */
  readonly FilingDeadline?: Date;

  /**
   * Boolean to indicate whether the office is partisan, e.g., true or false.  If not present, assumption is true.
   */
  readonly IsPartisan?: boolean;

  /**
   * Name of the office; can appear on the ballot.
   */
  readonly Name: InternationalizedText;

  /**
   * Links to one or more Person instances defined for the office holder.
   */
  readonly OfficeHolderPersonIds?: readonly string[];

  /**
   * For including office term-related information.
   */
  readonly Term?: Term;
}

/**
 * Schema for {@link Office}.
 */
export const OfficeSchema: z.ZodSchema<Office> = z.object({
  '@id': z.string(),
  '@type': z.literal('ElectionResults.Office'),
  ContactInformation: z.optional(z.lazy(/* istanbul ignore next */ () => ContactInformationSchema)),
  Description: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
  ElectionDistrictId: z.optional(z.string()),
  ExternalIdentifier: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => ExternalIdentifierSchema))),
  FilingDeadline: z.optional(DateSchema),
  IsPartisan: z.optional(z.boolean()),
  Name: z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema),
  OfficeHolderPersonIds: z.optional(z.array(z.string())),
  Term: z.optional(z.lazy(/* istanbul ignore next */ () => TermSchema)),
});

/**
 * Used to assign a name to a grouping of office definitions. It includes references to Office instances and a name to identify the grouping of references, e.g., "Judicial" or "Statewide", etc. SubOfficeGroup can be used to create a nested hierarchy of groupings. ElectionReport includes OfficeGroup.
 */
export interface OfficeGroup {
  readonly '@type': 'ElectionResults.OfficeGroup';

  /**
   * For use as needed and compatibility with the VIP schema.
   */
  readonly Label?: string;

  /**
   * Name of the office grouping.
   */
  readonly Name: string;

  /**
   * Link to one or more Office instances.
   */
  readonly OfficeIds?: readonly string[];

  /**
   * For defining a nested hierarchy of Office instance groupings.
   */
  readonly SubOfficeGroup?: readonly OfficeGroup[];
}

/**
 * Schema for {@link OfficeGroup}.
 */
export const OfficeGroupSchema: z.ZodSchema<OfficeGroup> = z.object({
  '@type': z.literal('ElectionResults.OfficeGroup'),
  Label: z.optional(z.string()),
  Name: z.string(),
  OfficeIds: z.optional(z.array(z.string())),
  SubOfficeGroup: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => OfficeGroupSchema))),
});

/**
 * For the appearance of a contest on a particular ballot style.
 */
export interface OrderedContest {
  readonly '@type': 'ElectionResults.OrderedContest';

  /**
   * The contest associated represented by OrderedContest.
   */
  readonly ContestId: string;

  /**
   * The contest selections for the ballot.
   */
  readonly OrderedContestSelectionIds?: readonly string[];
}

/**
 * Schema for {@link OrderedContest}.
 */
export const OrderedContestSchema: z.ZodSchema<OrderedContest> = z.object({
  '@type': z.literal('ElectionResults.OrderedContest'),
  ContestId: z.string(),
  OrderedContestSelectionIds: z.optional(z.array(z.string())),
});

/**
 * For the appearance of a header on a particular ballot style.
 */
export interface OrderedHeader {
  readonly '@type': 'ElectionResults.OrderedHeader';

  /**
   * Association to the header to be used.
   */
  readonly HeaderId: string;

  /**
   * For associating a header with ballot content, such as contests or nested headers.
   */
  readonly OrderedContent?: ReadonlyArray<OrderedContest | OrderedHeader>;
}

/**
 * Schema for {@link OrderedHeader}.
 */
export const OrderedHeaderSchema: z.ZodSchema<OrderedHeader> = z.object({
  '@type': z.literal('ElectionResults.OrderedHeader'),
  HeaderId: z.string(),
  OrderedContent: z.optional(z.array(z.union([z.lazy(/* istanbul ignore next */ () => OrderedContestSchema), z.lazy(/* istanbul ignore next */ () => OrderedHeaderSchema)]))),
});

/**
 * Identifies other counts associated with a contest.
 */
export interface OtherCounts {
  readonly '@type': 'ElectionResults.OtherCounts';

  /**
   * For filtering counts by device type.
   */
  readonly DeviceClass?: DeviceClass;

  /**
   * For filter counts by political geography or device or device type.
   */
  readonly GpUnitId: string;

  /**
   * Number of overvotes.
   */
  readonly Overvotes?: number;

  /**
   * Number of undervotes.
   */
  readonly Undervotes?: number;

  /**
   * Number of write-ins.
   */
  readonly WriteIns?: integer;
}

/**
 * Schema for {@link OtherCounts}.
 */
export const OtherCountsSchema: z.ZodSchema<OtherCounts> = z.object({
  '@type': z.literal('ElectionResults.OtherCounts'),
  DeviceClass: z.optional(z.lazy(/* istanbul ignore next */ () => DeviceClassSchema)),
  GpUnitId: z.string(),
  Overvotes: z.optional(z.number()),
  Undervotes: z.optional(z.number()),
  WriteIns: z.optional(integerSchema),
});

/**
 * Used to describe a political party that can then be referenced in other elements. ElectionReport includes Party. Candidate, PartyContest, PartyRegistration, and Person reference Party.
 * 
 * Party is an abstract type with one subtype Coalition, used to define coalitions.
 * 
 * The Color attribute specifies a 6-digit RGB code displayable using HTML.
 */
export interface Party {
  readonly '@id': string;

  readonly '@type': 'ElectionResults.Party';

  /**
   * Short name for the party, e.g., “DEM”.
   */
  readonly Abbreviation?: InternationalizedText;

  /**
   * For associating an HTML RGB color coding with the party.
   */
  readonly Color?: HtmlColorString;

  /**
   * For associating contact information regarding the party, e.g., party offices.
   */
  readonly ContactInformation?: ContactInformation;

  /**
   * For associating an ID with the party.
   */
  readonly ExternalIdentifier?: readonly ExternalIdentifier[];

  /**
   * For indicating whether the party is recognized by the election authority; “false” is assumed if not present.
   */
  readonly IsRecognizedParty?: boolean;

  /**
   * Identification of a Party's leader.
   */
  readonly LeaderPersonIds?: readonly string[];

  /**
   * A URI to the party’s graphical logo.
   */
  readonly LogoUri?: readonly AnnotatedUri[];

  /**
   * Official full name of the party, e.g., “Republican”; can appear on the ballot.
   */
  readonly Name: InternationalizedText;

  /**
   * The GpUnit(s) the party operates in or the top-most GpUnit.
   */
  readonly PartyScopeGpUnitIds?: readonly string[];

  /**
   * The slogan or motto used by a political party.
   */
  readonly Slogan?: InternationalizedText;
}

/**
 * Schema for {@link Party}.
 */
export const PartySchema: z.ZodSchema<Party> = z.object({
  '@id': z.string(),
  '@type': z.literal('ElectionResults.Party'),
  Abbreviation: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
  Color: z.optional(z.lazy(/* istanbul ignore next */ () => HtmlColorStringSchema)),
  ContactInformation: z.optional(z.lazy(/* istanbul ignore next */ () => ContactInformationSchema)),
  ExternalIdentifier: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => ExternalIdentifierSchema))),
  IsRecognizedParty: z.optional(z.boolean()),
  LeaderPersonIds: z.optional(z.array(z.string())),
  LogoUri: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => AnnotatedUriSchema))),
  Name: z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema),
  PartyScopeGpUnitIds: z.optional(z.array(z.string())),
  Slogan: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
});

/**
 * For a contest that involves choosing a party, typically for a straight party selection on the ballot.
 */
export interface PartyContest {
  readonly '@id': string;

  readonly '@type': 'ElectionResults.PartyContest';

  /**
   * Abbreviation for the contest.
   */
  readonly Abbreviation?: string;

  /**
   * Subtitle of the contest as it appears on the ballot.
   */
  readonly BallotSubTitle?: InternationalizedText;

  /**
   * Title of the contest as it appears on the ballot.
   */
  readonly BallotTitle?: InternationalizedText;

  /**
   * For associating a contest selection for the contest, i.e., a candidate, a ballot measure.
   */
  readonly ContestSelection?: ReadonlyArray<PartySelection | BallotMeasureSelection | CandidateSelection>;

  /**
   * For providing various counting status associated with the contest.
   */
  readonly CountStatus?: readonly CountStatus[];

  /**
   * Link to a GpUnit instance. For associating the contest with a reporting unit that represents the geographical scope of the contest, e.g., a district, etc.
   */
  readonly ElectionDistrictId: string;

  /**
   * For associating an ID with the contest.
   */
  readonly ExternalIdentifier?: readonly ExternalIdentifier[];

  /**
   * Boolean to indicate whether the selections in the contest are rotated. Assumed to be “no” if not present.
   */
  readonly HasRotation?: boolean;

  /**
   * Name of the contest, not necessarily as it appears on the ballot.
   */
  readonly Name: string;

  /**
   * For associating counts such as overvote and undervotes with the contest.
   */
  readonly OtherCounts?: readonly OtherCounts[];

  /**
   * For use when VoteVariation is other.
   */
  readonly OtherVoteVariation?: string;

  /**
   * Orderering for listing the contest for purposes of results display.  If not present, no order is assumed.
   */
  readonly SequenceOrder?: integer;

  /**
   * Number of subunits, e.g., precincts, that have completed reporting votes for this contest.
   */
  readonly SubUnitsReported?: integer;

  /**
   * Total number of subunits, e.g., precincts that have this contest on the ballot.
   */
  readonly TotalSubUnits?: integer;

  /**
   * Vote variation associated with the contest, e.g., n-of-m.
   */
  readonly VoteVariation?: VoteVariation;
}

/**
 * Schema for {@link PartyContest}.
 */
export const PartyContestSchema: z.ZodSchema<PartyContest> = z.object({
  '@id': z.string(),
  '@type': z.literal('ElectionResults.PartyContest'),
  Abbreviation: z.optional(z.string()),
  BallotSubTitle: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
  BallotTitle: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
  ContestSelection: z.optional(z.array(z.union([z.lazy(/* istanbul ignore next */ () => PartySelectionSchema), z.lazy(/* istanbul ignore next */ () => BallotMeasureSelectionSchema), z.lazy(/* istanbul ignore next */ () => CandidateSelectionSchema)]))),
  CountStatus: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => CountStatusSchema))),
  ElectionDistrictId: z.string(),
  ExternalIdentifier: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => ExternalIdentifierSchema))),
  HasRotation: z.optional(z.boolean()),
  Name: z.string(),
  OtherCounts: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => OtherCountsSchema))),
  OtherVoteVariation: z.optional(z.string()),
  SequenceOrder: z.optional(integerSchema),
  SubUnitsReported: z.optional(integerSchema),
  TotalSubUnits: z.optional(integerSchema),
  VoteVariation: z.optional(z.lazy(/* istanbul ignore next */ () => VoteVariationSchema)),
});

/**
 * For tracking the number of registered voters per party per geopolitical unit, i.e., for reporting on the number of registered voters of a particular party in a district or other type of reporting unit. Referenced by GpUnit.
 */
export interface PartyRegistration {
  readonly '@type': 'ElectionResults.PartyRegistration';

  /**
   * A count for tracking the number of registered voters.
   */
  readonly Count: integer;

  /**
   * Link to a Party instance. For associating a political party.
   */
  readonly PartyId: string;
}

/**
 * Schema for {@link PartyRegistration}.
 */
export const PartyRegistrationSchema: z.ZodSchema<PartyRegistration> = z.object({
  '@type': z.literal('ElectionResults.PartyRegistration'),
  Count: integerSchema,
  PartyId: z.string(),
});

/**
 * For a contest selection involving a party such as for a straight party selection on the ballot. It inherits the attributes of ContestSelection.
 */
export interface PartySelection {
  readonly '@id': string;

  readonly '@type': 'ElectionResults.PartySelection';

  /**
   * Link to one or more Party instances. For associating one or more parties with the party selection.
   */
  readonly PartyIds: readonly string[];

  /**
   * Order in which the candidate is listed on the ballot for purposes of results display. If not present, no order is assumed.
   */
  readonly SequenceOrder?: integer;

  /**
   * For associating the contest selection’s vote counts.
   */
  readonly VoteCounts?: readonly VoteCounts[];
}

/**
 * Schema for {@link PartySelection}.
 */
export const PartySelectionSchema: z.ZodSchema<PartySelection> = z.object({
  '@id': z.string(),
  '@type': z.literal('ElectionResults.PartySelection'),
  PartyIds: z.array(z.string()).min(1),
  SequenceOrder: z.optional(integerSchema),
  VoteCounts: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => VoteCountsSchema))),
});

/**
 * For defining information about a person; the person may be a candidate, election official, authority for a reporting unit, etc. ElectionReport includes Person. Candidate and ElectionAdministration and
 * GpUnit references Person. Person optionally references ContactInformation for associating contact information.
 * 
 * Multiple occurrences of the MiddleName attribute can be used as needed, e.g., for names such as "John Andrew Winston Smith".
 */
export interface Person {
  readonly '@id': string;

  readonly '@type': 'ElectionResults.Person';

  /**
   * For associating contact information with the person.
   */
  readonly ContactInformation?: readonly ContactInformation[];

  /**
   * Person’s date of birth.
   */
  readonly DateOfBirth?: Date;

  /**
   * For associating codes with the person.
   */
  readonly ExternalIdentifier?: readonly ExternalIdentifier[];

  /**
   * Person’s first (given) name.
   */
  readonly FirstName?: string;

  /**
   * Person’s full name.
   */
  readonly FullName?: InternationalizedText;

  /**
   * Person’s gender.
   */
  readonly Gender?: string;

  /**
   * Person’s last (family) name.
   */
  readonly LastName?: string;

  /**
   * Person’s middle name.
   */
  readonly MiddleName?: readonly string[];

  /**
   * Nickname associated with the person.
   */
  readonly Nickname?: string;

  /**
   * Links to a Party instance. For associating a political party with the person.
   */
  readonly PartyId?: string;

  /**
   * A prefix associated with the person, e.g., Mr.
   */
  readonly Prefix?: string;

  /**
   * Person’s profession.
   */
  readonly Profession?: InternationalizedText;

  /**
   * A suffix associated with the person, e.g., Jr.
   */
  readonly Suffix?: string;

  /**
   * A title associated with the person.
   */
  readonly Title?: InternationalizedText;
}

/**
 * Schema for {@link Person}.
 */
export const PersonSchema: z.ZodSchema<Person> = z.object({
  '@id': z.string(),
  '@type': z.literal('ElectionResults.Person'),
  ContactInformation: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => ContactInformationSchema))),
  DateOfBirth: z.optional(DateSchema),
  ExternalIdentifier: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => ExternalIdentifierSchema))),
  FirstName: z.optional(z.string()),
  FullName: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
  Gender: z.optional(z.string()),
  LastName: z.optional(z.string()),
  MiddleName: z.optional(z.array(z.string())),
  Nickname: z.optional(z.string()),
  PartyId: z.optional(z.string()),
  Prefix: z.optional(z.string()),
  Profession: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
  Suffix: z.optional(z.string()),
  Title: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
});

/**
 * Class/element describing a specific vote-capture device.
 */
export interface ReportingDevice {
  readonly '@id': string;

  readonly '@type': 'ElectionResults.ReportingDevice';

  /**
   * Unique identifier for one or more GpUnit instances.  For creating a reference to another GpUnit that is contained with the parent GpUnit.
   */
  readonly ComposingGpUnitIds?: readonly string[];

  /**
   * Used for reporting on details about the type of voting device used for the results in question.
   */
  readonly DeviceClass?: DeviceClass;

  /**
   * For associating an ID with the GpUnit, e.g., a district’s or county’s code.
   */
  readonly ExternalIdentifier?: readonly ExternalIdentifier[];

  /**
   * Name of the geopolitical unit.
   */
  readonly Name?: InternationalizedText;

  /**
   * Device's serial number or other unique identifier.
   */
  readonly SerialNumber?: string;
}

/**
 * Schema for {@link ReportingDevice}.
 */
export const ReportingDeviceSchema: z.ZodSchema<ReportingDevice> = z.object({
  '@id': z.string(),
  '@type': z.literal('ElectionResults.ReportingDevice'),
  ComposingGpUnitIds: z.optional(z.array(z.string())),
  DeviceClass: z.optional(z.lazy(/* istanbul ignore next */ () => DeviceClassSchema)),
  ExternalIdentifier: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => ExternalIdentifierSchema))),
  Name: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
  SerialNumber: z.optional(z.string()),
});

/**
 * For defining a geopolitical unit such as state, county, township, precinct, etc., using the ReportingUnitType enumeration. It inherits the attributes of GpUnit.
 * 
 * This class optionally references Person to associate one or more individuals, e.g., authorities, for the reporting unit. It also includes ContactInformation to provide contact addresses for the reporting unit, such as an address of a vote center.
 * 
 * Election references this class so as to identify the geographical scope of the election. In this case, the GpUnit element defined for the scope of the election may include ElectionAdministration to include election authority-related information.
 * 
 * The Type attribute uses the ReportingUnitType enumeration to specify the type of geopolitical geography being defined. ReportingUnitType contains the most common types of geographies, e.g., state, county, precinct, and so forth. If the reporting unit type is not listed in enumeration ReportingUnitType, use other and include the reporting unit type (that is not listed in the enumeration) in OtherType.
 * 
 * The IsDistricted boolean can be used in a number of ways. It is not strictly necessary, as it is possible to identify districts by their Type attribute or by examining the Contest instance's ElectionDistrict reference, which links to the election district associated with the contest. However, if a district is defined but is not linked from a contest, or if the type of district is not listed in the ReportingUnitType enumeration and therefore OtherType is used, then IsDistricted is necessary to identify the GpUnit as a district. The IsDistricted boolean can also be used to signify that a GpUnit defined as a jurisdiction, e.g., a county, is also used as a district for, e.g., county-wide contests.
 */
export interface ReportingUnit {
  readonly '@id': string;

  readonly '@type': 'ElectionResults.ReportingUnit';

  /**
   * A link to one or more Person instances describing an authority responsible for the reporting unit.
   */
  readonly AuthorityIds?: readonly string[];

  /**
   * Unique identifier for one or more GpUnit instances.  For creating a reference to another GpUnit that is contained with the parent GpUnit.
   */
  readonly ComposingGpUnitIds?: readonly string[];

  /**
   * For associating contact information with the reporting unit.
   */
  readonly ContactInformation?: ContactInformation;

  /**
   * For providing various counting status on types of ballots or other items.
   */
  readonly CountStatus?: readonly CountStatus[];

  /**
   * For use when the reporting unit serves as the authority in the election.
   */
  readonly ElectionAdministration?: ElectionAdministration;

  /**
   * For associating an ID with the GpUnit, e.g., a district’s or county’s code.
   */
  readonly ExternalIdentifier?: readonly ExternalIdentifier[];

  /**
   * Boolean to indicate whether the reporting unit is a district; assumed to be “false” if not present.
   */
  readonly IsDistricted?: boolean;

  /**
   * Boolean to indicate whether the reporting unit handles only mail-in or absentee ballot elections, assumed to be “false” if not present.
   */
  readonly IsMailOnly?: boolean;

  /**
   * Name of the geopolitical unit.
   */
  readonly Name?: InternationalizedText;

  /**
   * A number associated with the reporting unit; for compatibility with VIP.
   */
  readonly Number?: string;

  /**
   * For use when ReportingUnitType value is other.
   */
  readonly OtherType?: string;

  /**
   * For associating a count of registered voters per party with the geopolitical unit.
   */
  readonly PartyRegistration?: readonly PartyRegistration[];

  /**
   * For describing the reporting unit’s spatial extent (a polygon that shows the related area).
   */
  readonly SpatialDimension?: SpatialDimension;

  /**
   * Number of associated subunits such as precincts that have completed reporting.
   */
  readonly SubUnitsReported?: integer;

  /**
   * Total number of associated subunits such as precincts.
   */
  readonly TotalSubUnits?: integer;

  /**
   * Enumerated type of reporting unit, e.g., state, county, district, precinct, etc.
   */
  readonly Type: ReportingUnitType;

  /**
   * Number of voters who have participated in the election, i.e., shown up at the polls, including those who did not cast ballots.
   */
  readonly VotersParticipated?: integer;

  /**
   * Number of registered voters residing within the boundaries of the geopolitical unit.
   */
  readonly VotersRegistered?: integer;
}

/**
 * Schema for {@link ReportingUnit}.
 */
export const ReportingUnitSchema: z.ZodSchema<ReportingUnit> = z.object({
  '@id': z.string(),
  '@type': z.literal('ElectionResults.ReportingUnit'),
  AuthorityIds: z.optional(z.array(z.string())),
  ComposingGpUnitIds: z.optional(z.array(z.string())),
  ContactInformation: z.optional(z.lazy(/* istanbul ignore next */ () => ContactInformationSchema)),
  CountStatus: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => CountStatusSchema))),
  ElectionAdministration: z.optional(z.lazy(/* istanbul ignore next */ () => ElectionAdministrationSchema)),
  ExternalIdentifier: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => ExternalIdentifierSchema))),
  IsDistricted: z.optional(z.boolean()),
  IsMailOnly: z.optional(z.boolean()),
  Name: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
  Number: z.optional(z.string()),
  OtherType: z.optional(z.string()),
  PartyRegistration: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => PartyRegistrationSchema))),
  SpatialDimension: z.optional(z.lazy(/* istanbul ignore next */ () => SpatialDimensionSchema)),
  SubUnitsReported: z.optional(integerSchema),
  TotalSubUnits: z.optional(integerSchema),
  Type: z.lazy(/* istanbul ignore next */ () => ReportingUnitTypeSchema),
  VotersParticipated: z.optional(integerSchema),
  VotersRegistered: z.optional(integerSchema),
});

/**
 * For judicial retention or other types of retention contests. Retention contests can be treated essentially as ballot measure contests, however this element differs from
 * BallotMeasureContest in that it can include a reference to a candidate or the associated office.
 * 
 * This element uses BallotMeasureContest as a superclass. Therefore, it inherits the attributes of Contest as well as BallotMeasureContest.
 */
export interface RetentionContest {
  readonly '@id': string;

  readonly '@type': 'ElectionResults.RetentionContest';

  /**
   * Abbreviation for the contest.
   */
  readonly Abbreviation?: string;

  /**
   * Subtitle of the contest as it appears on the ballot.
   */
  readonly BallotSubTitle?: InternationalizedText;

  /**
   * Title of the contest as it appears on the ballot.
   */
  readonly BallotTitle?: InternationalizedText;

  /**
   * Link to a Candidate instance. For associating a candidate with the retention contest.
   */
  readonly CandidateId: string;

  /**
   * For a statement on the ballot associated with a “no” vote.
   */
  readonly ConStatement?: InternationalizedText;

  /**
   * For associating a contest selection for the contest, i.e., a candidate, a ballot measure.
   */
  readonly ContestSelection?: ReadonlyArray<PartySelection | BallotMeasureSelection | CandidateSelection>;

  /**
   * For providing various counting status associated with the contest.
   */
  readonly CountStatus?: readonly CountStatus[];

  /**
   * For a statement on the ballot detailing the effect of abstaining from voting on the ballot measure.
   */
  readonly EffectOfAbstain?: InternationalizedText;

  /**
   * Link to a GpUnit instance. For associating the contest with a reporting unit that represents the geographical scope of the contest, e.g., a district, etc.
   */
  readonly ElectionDistrictId: string;

  /**
   * For associating an ID with the contest.
   */
  readonly ExternalIdentifier?: readonly ExternalIdentifier[];

  /**
   * For full text on the ballot of the ballot measure.
   */
  readonly FullText?: InternationalizedText;

  /**
   * Boolean to indicate whether the selections in the contest are rotated. Assumed to be “no” if not present.
   */
  readonly HasRotation?: boolean;

  /**
   * For associating a URI with the ballot measure contest.
   */
  readonly InfoUri?: readonly AnnotatedUri[];

  /**
   * Name of the contest, not necessarily as it appears on the ballot.
   */
  readonly Name: string;

  /**
   * Link to an Office instance. For associating an office description with the retention contest.
   */
  readonly OfficeId?: string;

  /**
   * For associating counts such as overvote and undervotes with the contest.
   */
  readonly OtherCounts?: readonly OtherCounts[];

  /**
   * Used when BallotMeasureType is other.
   */
  readonly OtherType?: string;

  /**
   * For use when VoteVariation is other.
   */
  readonly OtherVoteVariation?: string;

  /**
   * For a statement on the ballot of the number or percentage of votes needed to approve or pass the ballot measure.
   */
  readonly PassageThreshold?: InternationalizedText;

  /**
   * For a statement on the ballot associated with a “yes” vote.
   */
  readonly ProStatement?: InternationalizedText;

  /**
   * Orderering for listing the contest for purposes of results display.  If not present, no order is assumed.
   */
  readonly SequenceOrder?: integer;

  /**
   * Number of subunits, e.g., precincts, that have completed reporting votes for this contest.
   */
  readonly SubUnitsReported?: integer;

  /**
   * For a summary on the ballot of the ballot measure.
   */
  readonly SummaryText?: InternationalizedText;

  /**
   * Total number of subunits, e.g., precincts that have this contest on the ballot.
   */
  readonly TotalSubUnits?: integer;

  /**
   * For indicating the type of ballot measure.
   */
  readonly Type?: BallotMeasureType;

  /**
   * Vote variation associated with the contest, e.g., n-of-m.
   */
  readonly VoteVariation?: VoteVariation;
}

/**
 * Schema for {@link RetentionContest}.
 */
export const RetentionContestSchema: z.ZodSchema<RetentionContest> = z.object({
  '@id': z.string(),
  '@type': z.literal('ElectionResults.RetentionContest'),
  Abbreviation: z.optional(z.string()),
  BallotSubTitle: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
  BallotTitle: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
  CandidateId: z.string(),
  ConStatement: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
  ContestSelection: z.optional(z.array(z.union([z.lazy(/* istanbul ignore next */ () => PartySelectionSchema), z.lazy(/* istanbul ignore next */ () => BallotMeasureSelectionSchema), z.lazy(/* istanbul ignore next */ () => CandidateSelectionSchema)]))),
  CountStatus: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => CountStatusSchema))),
  EffectOfAbstain: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
  ElectionDistrictId: z.string(),
  ExternalIdentifier: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => ExternalIdentifierSchema))),
  FullText: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
  HasRotation: z.optional(z.boolean()),
  InfoUri: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => AnnotatedUriSchema))),
  Name: z.string(),
  OfficeId: z.optional(z.string()),
  OtherCounts: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => OtherCountsSchema))),
  OtherType: z.optional(z.string()),
  OtherVoteVariation: z.optional(z.string()),
  PassageThreshold: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
  ProStatement: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
  SequenceOrder: z.optional(integerSchema),
  SubUnitsReported: z.optional(integerSchema),
  SummaryText: z.optional(z.lazy(/* istanbul ignore next */ () => InternationalizedTextSchema)),
  TotalSubUnits: z.optional(integerSchema),
  Type: z.optional(z.lazy(/* istanbul ignore next */ () => BallotMeasureTypeSchema)),
  VoteVariation: z.optional(z.lazy(/* istanbul ignore next */ () => VoteVariationSchema)),
});

/**
 * For defining a schedule associated with a particular election office or location. ContactInformation includes Schedule.
 */
export interface Schedule {
  readonly '@type': 'ElectionResults.Schedule';

  /**
   * For the ending date of the schedule.
   */
  readonly EndDate?: Date;

  /**
   * For specifying a range of hours for a schedule.
   */
  readonly Hours?: readonly Hours[];

  /**
   * If an appointment is only by appointment; assumed to be “no” if not present.
   */
  readonly IsOnlyByAppointment?: boolean;

  /**
   * If an appointment can by appointment presumably as desired; assumed to be “no” if not present.
   */
  readonly IsOrByAppointment?: boolean;

  /**
   * If an appointment may be subject to change; assumed to be “no” if not present.
   */
  readonly IsSubjectToChange?: boolean;

  /**
   * For use as needed and compatibility with the VIP schema.
   */
  readonly Label?: string;

  /**
   * For the starting date of the schedule.
   */
  readonly StartDate?: Date;
}

/**
 * Schema for {@link Schedule}.
 */
export const ScheduleSchema: z.ZodSchema<Schedule> = z.object({
  '@type': z.literal('ElectionResults.Schedule'),
  EndDate: z.optional(DateSchema),
  Hours: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => HoursSchema))),
  IsOnlyByAppointment: z.optional(z.boolean()),
  IsOrByAppointment: z.optional(z.boolean()),
  IsSubjectToChange: z.optional(z.boolean()),
  Label: z.optional(z.string()),
  StartDate: z.optional(DateSchema),
});

/**
 * For defining the spatial layout of a GpUnit, e.g., a map or a spatial extent (a polygon that shows the related area) for various purposes, including to visualize election results, to understand the composition of districts, or to determine whether GpUnit instances are properly related. GpUnit includes SpatialDimension.
 */
export interface SpatialDimension {
  readonly '@type': 'ElectionResults.SpatialDimension';

  /**
   * Typically a URI to a map of the GpUnit.
   */
  readonly MapUri?: readonly AnnotatedUri[];

  /**
   * For associating a GpUnit
   *       element&#8217;s spatial extent information.
   */
  readonly SpatialExtent?: SpatialExtent;
}

/**
 * Schema for {@link SpatialDimension}.
 */
export const SpatialDimensionSchema: z.ZodSchema<SpatialDimension> = z.object({
  '@type': z.literal('ElectionResults.SpatialDimension'),
  MapUri: z.optional(z.array(z.lazy(/* istanbul ignore next */ () => AnnotatedUriSchema))),
  SpatialExtent: z.optional(z.lazy(/* istanbul ignore next */ () => SpatialExtentSchema)),
});

/**
 * SpatialDimension includes SpatialExtent for defining a GpUnit instance's spatial extent data and the format used for the spatial extent.
 */
export interface SpatialExtent {
  readonly '@type': 'ElectionResults.SpatialExtent';

  /**
   * The data coordinates constituting the spatial extent.
   */
  readonly Coordinates: string;

  /**
   * Enumerated type for the format used, e.g., gml, kml, wkt, etc.
   */
  readonly Format: GeoSpatialFormat;
}

/**
 * Schema for {@link SpatialExtent}.
 */
export const SpatialExtentSchema: z.ZodSchema<SpatialExtent> = z.object({
  '@type': z.literal('ElectionResults.SpatialExtent'),
  Coordinates: z.string(),
  Format: z.lazy(/* istanbul ignore next */ () => GeoSpatialFormatSchema),
});

/**
 * For describing information about an office term. Term is included by Office.
 */
export interface Term {
  readonly '@type': 'ElectionResults.Term';

  /**
   * End date for the current term of the office.
   */
  readonly EndDate?: Date;

  /**
   * For use as needed and compatibility with the VIP schema.
   */
  readonly Label?: string;

  /**
   * Start date for the current term of the office.
   */
  readonly StartDate?: Date;

  /**
   * Enumerated type of term, e.g., full-term, unexpired-term, etc.
   */
  readonly Type?: OfficeTermType;
}

/**
 * Schema for {@link Term}.
 */
export const TermSchema: z.ZodSchema<Term> = z.object({
  '@type': z.literal('ElectionResults.Term'),
  EndDate: z.optional(DateSchema),
  Label: z.optional(z.string()),
  StartDate: z.optional(DateSchema),
  Type: z.optional(z.lazy(/* istanbul ignore next */ () => OfficeTermTypeSchema)),
});

/**
 * For reporting on vote counts for contest selections in a contest. VoteCounts includes Counts as an extension base and therefore inherits the elements from Counts, but it is included directly by ContestSelection.
 */
export interface VoteCounts {
  readonly '@type': 'ElectionResults.VoteCounts';

  /**
   * Count of contest votes cast; can include a fractional component in special cases.
   */
  readonly Count: number;

  /**
   * For filtering counts by device type.
   */
  readonly DeviceClass?: DeviceClass;

  /**
   * For filtering counts by political geography or device or device type.
   */
  readonly GpUnitId: string;

  /**
   * Boolean to indicate if votes are suppressed for voter privacy, e.g., true or false. Assumed to be false if not present.
   */
  readonly IsSuppressedForPrivacy?: boolean;

  /**
   * Used when Type is other.
   */
  readonly OtherType?: string;

  /**
   * An identification of the RCV round being reported.
   */
  readonly Round?: integer;

  /**
   * The type of count being used as a filter on the vote counts, e.g., election day, early voting, etc.
   */
  readonly Type: CountItemType;
}

/**
 * Schema for {@link VoteCounts}.
 */
export const VoteCountsSchema: z.ZodSchema<VoteCounts> = z.object({
  '@type': z.literal('ElectionResults.VoteCounts'),
  Count: z.number(),
  DeviceClass: z.optional(z.lazy(/* istanbul ignore next */ () => DeviceClassSchema)),
  GpUnitId: z.string(),
  IsSuppressedForPrivacy: z.optional(z.boolean()),
  OtherType: z.optional(z.string()),
  Round: z.optional(integerSchema),
  Type: z.lazy(/* istanbul ignore next */ () => CountItemTypeSchema),
});

