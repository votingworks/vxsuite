import { promises as fs } from 'node:fs';
import { dirname, parse, relative } from 'node:path';
import { isImageMimeType, isTextMimeType } from './mime';

/**
 * A resource to be converted.
 */
export interface Resource {
  readonly path: string;
  readonly tsPath: string;
  readonly mimeType: string;
}

/**
 * Returns a TypeScript file that provides access to a directory resource
 * via an `asDirectoryPath` method. When called, the method will copy the
 * directory contents into a temporary directory and return its path.
 */
function getTypeScriptForDirectoryResource(path: string, tsPath: string) {
  return `/* Generated by res-to-ts. DO NOT EDIT */
/* eslint-disable */
/* istanbul ignore file */

import * as fs from 'node:fs';
import { tmpdir } from 'node:os';
import { resolve, sep } from 'node:path';

const copiedDirectories: string[] = [];

if (typeof jest !== 'undefined') {
  afterAll(() => {
    for (const copiedDirectory of copiedDirectories) {
      fs.rmSync(copiedDirectory, { recursive: true, force: true });
    }
  });
}

export function asDirectoryPath(): string {
  const tmpDir = fs.mkdtempSync(tmpdir() + sep);
  const resolved = resolve(
    __dirname,
    '${relative(dirname(tsPath), path)}'
  );
  fs.cpSync(resolved, tmpDir, { recursive: true });
  copiedDirectories.push(tmpDir);
  return tmpDir;
}

`;
}

/**
 * Converts a resource to be readable as a TypeScript file.
 */
export async function convert({
  path,
  mimeType,
  tsPath,
}: Resource): Promise<string> {
  // Special casing for directories, as we don't embed the contents into the file
  if ((await fs.lstat(path)).isDirectory()) {
    return getTypeScriptForDirectoryResource(path, tsPath);
  }

  const pathParts = parse(path);
  const relativePath = relative(process.cwd(), path);
  const isImageResource = isImageMimeType(mimeType);
  const isTextResource = isTextMimeType(mimeType);
  const isElectionDefinition =
    pathParts.ext === '.json' && pathParts.name.startsWith('election');
  const lines: string[] = [
    `/* Generated by res-to-ts. DO NOT EDIT */`,
    `/* eslint-disable */`,
    `/* istanbul ignore file */`,
    ``,
    `import { Buffer } from 'node:buffer';`,
    `import { cpSync, existsSync, mkdtempSync, readFileSync } from 'node:fs';`,
    `import { tmpdir } from 'node:os';`,
    `import { dirname, join, sep } from 'node:path';`,
  ];

  if (isImageResource) {
    lines.push(
      `import { createCanvas, Image, ImageData, loadImage } from 'canvas';`,
      ``
    );
  }

  if (isElectionDefinition) {
    lines.push(
      `import {`,
      `  Election,`,
      `  ElectionDefinition,`,
      `  ElectionPackage,`,
      `  safeParseElectionDefinition,`,
      `  DEFAULT_SYSTEM_SETTINGS,`,
      `} from '@votingworks/types';`
    );
  }

  lines.push(
    ``,
    `/**`,
    ` * Get the path to the resource ${relativePath}.`,
    ` */`,
    `function getResourcePath(): string {`,
    `  let rootDir = __dirname;`,
    `  do {`,
    `    if (existsSync(join(rootDir, 'package.json'))) {`,
    `      return join(rootDir, '${relativePath}');`,
    `    }`,
    `    let parentDir = dirname(rootDir);`,
    `    if (parentDir === '.' || parentDir === rootDir) {`,
    `      break;`,
    `    }`,
    `    rootDir = parentDir;`,
    `  } while (true);`,
    `  throw new Error('Could not find resource path');`,
    `}`,
    ``,
    `/**`,
    ` * MIME type of ${relativePath}.`,
    ` */`,
    `export const mimeType = '${mimeType}';`,
    ``,
    `/**`,
    ` * Path to a file containing this file's contents.`,
    ` */`,
    `export function asFilePath(): string {`,
    `  const directoryPath = mkdtempSync(tmpdir() + sep);`,
    `  const filePath = join(directoryPath, '${pathParts.base}');`,
    `  cpSync(getResourcePath(), filePath);`,
    `  return filePath;`,
    `}`,
    ``,
    `/**`,
    ` * Convert to a \`data:\` URL of ${relativePath}, suitable for embedding in HTML.`,
    ` */`,
    `export function asDataUrl(): string {`,
    `  return \`data:\${mimeType};base64,\${asBuffer().toString('base64')}\`;`,
    `}`,
    ``,
    `/**`,
    ` * Raw data of ${relativePath}.`,
    ` */`,
    `export function asBuffer(): Buffer {`,
    `  return readFileSync(getResourcePath());`,
    `}`
  );

  if (isTextResource) {
    lines.push(
      ``,
      `/**`,
      ` * Text content of ${relativePath}.`,
      ` */`,
      `export function asText(): string {`,
      `  return readFileSync(getResourcePath(), 'utf-8');`,
      `}`
    );
  }

  if (isImageResource) {
    lines.push(
      ``,
      `/**`,
      ` * Converts ${relativePath} to an \`ImageData\`.`,
      ` */`,
      `export async function asImageData(): Promise<ImageData> {`,
      `  const image = await loadImage(getResourcePath());`,
      `  const canvas = createCanvas(image.width, image.height);`,
      `  const context = canvas.getContext('2d');`,
      `  context.drawImage(image, 0, 0);`,
      `  return context.getImageData(0, 0, image.width, image.height);`,
      `}`
    );
  }

  if (isElectionDefinition) {
    lines.push(
      ``,
      `/**`,
      ` * Full election definition for ${relativePath}.`,
      ` */`,
      `export function readElectionDefinition(): ElectionDefinition {`,
      `  return safeParseElectionDefinition(asText()).unsafeUnwrap();`,
      `}`,
      ``,
      `/**`,
      ` * Election definition for ${relativePath}.`,
      ` */`,
      `export function readElection(): Election {`,
      `  return readElectionDefinition().election;`,
      `}`,
      ``,
      `/**`,
      ` * Election package for ${relativePath}.`,
      ` */`,
      `export function toElectionPackage(systemSettings = DEFAULT_SYSTEM_SETTINGS): ElectionPackage {`,
      `  return {`,
      `    electionDefinition: readElectionDefinition(),`,
      `    systemSettings,`,
      `  };`,
      `}`
    );
  }

  return lines.join('\n');
}
