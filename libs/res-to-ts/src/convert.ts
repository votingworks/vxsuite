import { promises as fs } from 'node:fs';
import { sha256 } from 'js-sha256';
import { dirname, parse, relative } from 'node:path';
import { isImageMimeType, isTextMimeType } from './mime';

/**
 * A resource to be converted.
 */
export interface Resource {
  readonly path: string;
  readonly tsPath: string;
  readonly mimeType: string;
}

/**
 * Returns a TypeScript file that provides access to a directory resource
 * via an `asDirectoryPath` method. When called, the method will copy the
 * directory contents into a temporary directory and return its path.
 */
function getTypeScriptForDirectoryResource(path: string, tsPath: string) {
  return `/* Generated by res-to-ts. DO NOT EDIT */
/* eslint-disable */
/* istanbul ignore file */

import * as fs from 'node:fs';
import { tmpdir } from 'node:os';
import { resolve, sep } from 'node:path';

const copiedDirectories: string[] = [];

if (typeof jest !== 'undefined') {
  afterAll(() => {
    for (const copiedDirectory of copiedDirectories) {
      fs.rmSync(copiedDirectory, { recursive: true, force: true });
    }
  });
}

export function asDirectoryPath(): string {
  const tmpDir = fs.mkdtempSync(tmpdir() + sep);
  const resolved = resolve(
    __dirname,
    '${relative(dirname(tsPath), path)}'
  );
  fs.cpSync(resolved, tmpDir, { recursive: true });
  copiedDirectories.push(tmpDir);
  return tmpDir;
}

`;
}

/**
 * Converts a resource to be readable as a TypeScript file.
 */
export async function convert({
  path,
  mimeType,
  tsPath,
}: Resource): Promise<string> {
  // Special casing for directories, as we don't embed the contents into the file
  if ((await fs.lstat(path)).isDirectory()) {
    return getTypeScriptForDirectoryResource(path, tsPath);
  }

  const pathParts = parse(path);
  const relativePath = relative(process.cwd(), path);
  const isImageResource = isImageMimeType(mimeType);
  const isTextResource = isTextMimeType(mimeType);
  const isElectionDefinition =
    pathParts.ext === '.json' && pathParts.name.startsWith('election');
  const resourceData = await fs.readFile(path);
  const lines: string[] = [
    `/* Generated by res-to-ts. DO NOT EDIT */`,
    `/* eslint-disable */`,
    `/* istanbul ignore file */`,
    ``,
    `import { Buffer } from 'node:buffer';`,
    `import { mkdtempSync, writeFileSync } from 'node:fs';`,
    `import { tmpdir } from 'node:os';`,
    `import { join, sep } from 'node:path';`,
  ];

  if (isImageResource) {
    lines.push(
      `import { createCanvas, Image, ImageData, loadImage } from 'canvas';`,
      ``
    );
  }

  if (isElectionDefinition) {
    lines.push(
      `import { ElectionPackage, safeParseElectionDefinition, DEFAULT_SYSTEM_SETTINGS } from '@votingworks/types';`
    );
  }

  const hash = sha256(resourceData);

  lines.push(
    ``,
    `/**`,
    ` * Data of ${relativePath} encoded as base64.`,
    ` *`,
    ` * SHA-256 hash of file data: ${hash}`,
    ` */`,
    `const resourceDataBase64 = '${resourceData.toString('base64')}';`,
    ``,
    `/**`,
    ` * MIME type of ${relativePath}.`,
    ` */`,
    `export const mimeType = '${mimeType}';`,
    ``,
    `/**`,
    ` * Path to a file containing this file's contents.`,
    ` *`,
    ` * SHA-256 hash of file data: ${hash}`,
    ` */`,
    `export function asFilePath(): string {`,
    `  const directoryPath = mkdtempSync(tmpdir() + sep);`,
    `  const filePath = join(directoryPath, '${pathParts.base}');`,
    `  writeFileSync(filePath, asBuffer());`,
    `  return filePath;`,
    `}`,
    ``,
    `/**`,
    ` * Convert to a \`data:\` URL of ${relativePath}, suitable for embedding in HTML.`,
    ` *`,
    ` * SHA-256 hash of file data: ${hash}`,
    ` */`,
    `export function asDataUrl(): string {`,
    `  return \`data:\${mimeType};base64,\${resourceDataBase64}\`;`,
    `}`,
    ``,
    `/**`,
    ` * Raw data of ${relativePath}.`,
    ` *`,
    ` * SHA-256 hash of file data: ${hash}`,
    ` */`,
    `export function asBuffer(): Buffer {`,
    `  return Buffer.from(resourceDataBase64, 'base64');`,
    `}`
  );

  if (isTextResource) {
    lines.push(
      ``,
      `/**`,
      ` * Text content of ${relativePath}.`,
      ` *`,
      ` * SHA-256 hash of file data: ${hash}`,
      ` */`,
      `export function asText(): string {`,
      `  return asBuffer().toString('utf-8');`,
      `}`
    );
  }

  if (isImageResource) {
    lines.push(
      ``,
      `/**`,
      ` * Converts ${relativePath} to an \`ImageData\`.`,
      ` *`,
      ` * SHA-256 hash of file data: ${hash}`,
      ` */`,
      `export async function asImageData(): Promise<ImageData> {`,
      `  const image = await loadImage(asBuffer());`,
      `  const canvas = createCanvas(image.width, image.height);`,
      `  const context = canvas.getContext('2d');`,
      `  context.drawImage(image, 0, 0);`,
      `  return context.getImageData(0, 0, image.width, image.height);`,
      `}`
    );
  }

  if (isElectionDefinition) {
    lines.push(
      ``,
      `/**`,
      ` * Full election definition for ${relativePath}.`,
      ` *`,
      ` * SHA-256 hash of file data: ${hash}`,
      ` */`,
      `export const electionDefinition = safeParseElectionDefinition(`,
      `  asText()`,
      `).unsafeUnwrap();`,
      ``,
      `/**`,
      ` * Election definition for ${relativePath}.`,
      ` *`,
      ` * SHA-256 hash of file data: ${hash}`,
      ` */`,
      `export const election = electionDefinition.election;`,
      ``,
      `/**`,
      ` * Election package for ${relativePath}.`,
      ` *`,
      ` * SHA-256 hash of file data: ${hash}`,
      ` */`,
      `export function toElectionPackage(systemSettings = DEFAULT_SYSTEM_SETTINGS): ElectionPackage {`,
      `  return {`,
      `    electionDefinition,`,
      `    systemSettings,`,
      `  };`,
      `}`
    );
  }

  return lines.join('\n');
}
