import {
  ElectionManagerCardData,
  AnyCardDataSchema,
  Card,
  CardSummaryReady,
  CardProgramming,
  CardStorage,
  DippedSmartcardAuth,
  InsertedSmartcardAuth,
  Optional,
  PollWorkerCardData,
  safeParseJson,
  SystemAdministratorCardData,
  User,
} from '@votingworks/types';
import { err, ok, throwIllegalValue, wrapException } from '@votingworks/basics';
import { LogEventId, Logger } from '@votingworks/logging';

import { Lock } from '../use_lock';

export const CARD_POLLING_INTERVAL = 100;

export function parseUserFromCardSummary(
  cardSummary: CardSummaryReady
): Optional<User> {
  if (!cardSummary.shortValue) return undefined;
  const cardData = safeParseJson(
    cardSummary.shortValue,
    AnyCardDataSchema
  ).ok();
  if (!cardData) return undefined;
  switch (cardData.t) {
    case 'system_administrator':
      return { role: 'system_administrator', passcode: cardData.p };
    case 'election_manager':
      return {
        role: 'election_manager',
        electionHash: cardData.h,
        passcode: cardData.p,
      };
    case 'poll_worker':
      return { role: 'poll_worker', electionHash: cardData.h };
    case 'voter':
      return {
        role: 'voter',
        createdAt: cardData.c,
        ballotStyleId: cardData.bs,
        precinctId: cardData.pr,
        voidedAt: cardData.uz,
        ballotPrintedAt: cardData.bp,
        updatedAt: cardData.u,
        markMachineId: cardData.m,
      };
    /* istanbul ignore next - compile time check for completeness */
    default:
      throwIllegalValue(cardData, 't');
  }
}

export function buildCardStorage(
  cardSummary: CardSummaryReady,
  cardApi: Card,
  cardWriteLock: Lock
): CardStorage {
  return {
    hasStoredData: !!cardSummary.longValueExists,

    readStoredObject: (schema) => cardApi.readLongObject(schema),

    readStoredString: async () => {
      try {
        const value = await cardApi.readLongString();
        return ok(value || undefined);
      } catch (error) {
        return wrapException(error);
      }
    },

    readStoredUint8Array: async () => {
      try {
        const value = await cardApi.readLongUint8Array();
        return ok(value && value.length > 0 ? value : undefined);
      } catch (error) {
        return wrapException(error);
      }
    },

    writeStoredData: async (value) => {
      if (!cardWriteLock.lock()) {
        return err(new Error('Card write in progress'));
      }
      try {
        if (value instanceof Uint8Array) {
          await cardApi.writeLongUint8Array(value);
        } else {
          await cardApi.writeLongObject(value);
        }
        return ok();
      } catch (error) {
        return wrapException(error);
      } finally {
        cardWriteLock.unlock();
      }
    },

    clearStoredData: async () => {
      if (!cardWriteLock.lock()) {
        return err(new Error('Card write in progress'));
      }
      try {
        await cardApi.writeLongUint8Array(Uint8Array.of());
        return ok();
      } catch (error) {
        return wrapException(error);
      } finally {
        cardWriteLock.unlock();
      }
    },
  };
}

/**
 * Builds an interface for smartcard programming, meant to augment the base smartcard interface
 * generated by buildCardStorage
 */
export function buildCardProgramming(
  cardSummary: CardSummaryReady,
  cardApi: Card,
  cardWriteLock: Lock,
  logger?: Logger
): CardProgramming {
  const programmedUser = parseUserFromCardSummary(cardSummary);

  const programUser: CardProgramming['programUser'] = async (userData) => {
    const { role } = userData;
    try {
      if (!cardWriteLock.lock()) {
        throw new Error('Card write in progress');
      }
      switch (role) {
        case 'system_administrator': {
          const cardData: SystemAdministratorCardData = {
            t: 'system_administrator',
            p: userData.passcode,
          };
          await cardApi.overrideWriteProtection();
          await cardApi.writeShortValue(JSON.stringify(cardData));
          break;
        }
        case 'election_manager': {
          const cardData: ElectionManagerCardData = {
            t: 'election_manager',
            h: userData.electionHash,
            p: userData.passcode,
          };
          await cardApi.overrideWriteProtection();
          await cardApi.writeShortAndLongValues({
            shortValue: JSON.stringify(cardData),
            longValue: userData.electionData,
          });
          break;
        }
        case 'poll_worker': {
          const cardData: PollWorkerCardData = {
            t: 'poll_worker',
            h: userData.electionHash,
          };
          await cardApi.overrideWriteProtection();
          await cardApi.writeShortValue(JSON.stringify(cardData));
          break;
        }
        /* istanbul ignore next: Compile-time check for completeness */
        default:
          throwIllegalValue(role);
      }
      return ok();
    } catch (error) {
      return wrapException(error);
    } finally {
      cardWriteLock.unlock();
    }
  };

  const unprogramUser: CardProgramming['unprogramUser'] = async () => {
    if (!programmedUser) {
      // Short-circuit if the card is already unprogrammed
      return ok();
    }
    try {
      if (!cardWriteLock.lock()) {
        throw new Error('Card write in progress');
      }
      await cardApi.overrideWriteProtection();
      await cardApi.writeShortAndLongValues({
        shortValue: '',
        longValue: '',
      });
      return ok();
    } catch (error) {
      return wrapException(error);
    } finally {
      cardWriteLock.unlock();
    }
  };

  return {
    programmedUser,

    programUser: async (userData) => {
      if (!logger) {
        return await programUser(userData);
      }

      const { role } = userData;
      await logger.log(
        LogEventId.SmartcardProgramInit,
        'system_administrator',
        {
          message: `Programming ${role} smartcard...`,
          programmedUserRole: role,
        }
      );
      const result = await programUser(userData);
      await logger.log(
        LogEventId.SmartcardProgramComplete,
        'system_administrator',
        {
          disposition: result.isOk() ? 'success' : 'failure',
          message: result.isOk()
            ? `Successfully programmed ${role} smartcard.`
            : `Error programming ${role} smartcard.`,
          programmedUserRole: role,
        }
      );
      return result;
    },

    unprogramUser: async () => {
      if (!logger) {
        return await unprogramUser();
      }

      const programmedUserRole = programmedUser?.role || 'unprogrammed';
      await logger.log(
        LogEventId.SmartcardUnprogramInit,
        'system_administrator',
        {
          message: `Unprogramming ${programmedUserRole} smartcard...`,
          programmedUserRole,
        }
      );
      const result = await unprogramUser();
      if (result.isOk()) {
        await logger.log(
          LogEventId.SmartcardUnprogramComplete,
          'system_administrator',
          {
            disposition: 'success',
            message:
              programmedUserRole === 'unprogrammed'
                ? 'Smartcard already unprogrammed (no-op).'
                : `Successfully unprogrammed ${programmedUserRole} smartcard.`,
            previousProgrammedUserRole: programmedUserRole,
          }
        );
      } else {
        await logger.log(
          LogEventId.SmartcardUnprogramComplete,
          'system_administrator',
          {
            disposition: 'failure',
            message: `Error unprogramming ${programmedUserRole} smartcard.`,
            programmedUserRole,
          }
        );
      }
      return result;
    },
  };
}

// Below, we define some useful type guards for checking who's logged in
// We use function overloads to make them work with either Inserted or Dipped auth

export function isSystemAdministratorAuth(
  auth: InsertedSmartcardAuth.Auth
): auth is InsertedSmartcardAuth.SystemAdministratorLoggedIn;
export function isSystemAdministratorAuth(
  auth: DippedSmartcardAuth.Auth
): auth is DippedSmartcardAuth.SystemAdministratorLoggedIn;
export function isSystemAdministratorAuth(
  auth: InsertedSmartcardAuth.Auth | DippedSmartcardAuth.Auth
): boolean {
  return (
    auth.status === 'logged_in' && auth.user.role === 'system_administrator'
  );
}

export function isElectionManagerAuth(
  auth: InsertedSmartcardAuth.Auth
): auth is InsertedSmartcardAuth.ElectionManagerLoggedIn;
export function isElectionManagerAuth(
  auth: DippedSmartcardAuth.Auth
): auth is DippedSmartcardAuth.ElectionManagerLoggedIn;
export function isElectionManagerAuth(
  auth: InsertedSmartcardAuth.Auth | DippedSmartcardAuth.Auth
): boolean {
  return auth.status === 'logged_in' && auth.user.role === 'election_manager';
}

export function isPollWorkerAuth(
  auth: InsertedSmartcardAuth.Auth
): auth is InsertedSmartcardAuth.PollWorkerLoggedIn {
  return auth.status === 'logged_in' && auth.user.role === 'poll_worker';
}

export function isVoterAuth(
  auth: InsertedSmartcardAuth.Auth
): auth is InsertedSmartcardAuth.VoterLoggedIn {
  return auth.status === 'logged_in' && auth.user.role === 'voter';
}

export function isCardlessVoterAuth(
  auth: InsertedSmartcardAuth.Auth
): auth is InsertedSmartcardAuth.CardlessVoterLoggedIn {
  return auth.status === 'logged_in' && auth.user.role === 'cardless_voter';
}
