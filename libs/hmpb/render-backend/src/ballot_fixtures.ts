import {
  assert,
  assertDefined,
  find,
  range,
  throwIllegalValue,
} from '@votingworks/basics';
import {
  electionSample,
  electionFamousNames2021Fixtures,
} from '@votingworks/fixtures';
import {
  AnyElement,
  gridPosition,
  layOutAllBallots,
  measurements,
  Document,
  Rectangle,
  BubblePosition,
  LayoutDensity,
} from '@votingworks/hmpb-layout';
import {
  AnyContest,
  BallotPaperSize,
  Contests,
  Election,
  getBallotStyle,
  getContests,
  GridLayout,
  Id,
  Vote,
  VotesDict,
} from '@votingworks/types';
import { join } from 'path';

export const fixturesDir = join(__dirname, '../fixtures');
export const famousNamesDir = join(fixturesDir, 'famous-names');
export const sampleElectionDir = join(fixturesDir, 'sample-election');

export function voteToOptionId(vote: Vote[number], contest: AnyContest): Id {
  switch (contest.type) {
    case 'candidate': {
      assert(typeof vote === 'object');
      return vote.id;
    }
    case 'yesno':
      return vote === 'yes' ? contest.yesOption.id : contest.noOption.id;
    default:
      throwIllegalValue(contest);
  }
}

interface MarkBallotParams {
  ballot: Document;
  gridLayout: GridLayout;
  votes: VotesDict;
  contests: Contests;
  paperSize: BallotPaperSize;
  layoutDensity: LayoutDensity;
}

export function markBallot({
  ballot,
  gridLayout,
  votes,
  contests,
  paperSize,
  layoutDensity,
}: MarkBallotParams): Document {
  const m = measurements(paperSize, layoutDensity);
  function marksForPage(page: number): AnyElement[] {
    const sheetNumber = Math.ceil(page / 2);
    const side = page % 2 === 1 ? 'front' : 'back';
    const pagePositions = gridLayout.gridPositions.filter(
      (position) =>
        position.sheetNumber === sheetNumber && position.side === side
    );
    return Object.entries(votes).flatMap(([contestId, contestVotes]) => {
      if (!contestVotes) return [];
      const contestPositions = pagePositions.filter(
        (position) => position.contestId === contestId
      );
      if (contestPositions.length === 0) return []; // Contest not on this page
      return contestVotes?.map((vote): Rectangle => {
        const optionPosition = find(
          contestPositions,
          (position) =>
            position.type === 'option' &&
            position.optionId ===
              voteToOptionId(
                vote,
                find(contests, (c) => c.id === contestId)
              )
        );
        // Add offset to get bubble center (since interpreter indexes from
        // timing marks, while layout indexes from ballot edge)
        const position = gridPosition(
          {
            column: optionPosition.column + 1,
            row: optionPosition.row + 1,
          },
          m
        );
        return {
          type: 'Rectangle',
          // Offset by half mark width/height
          x: position.x - 5,
          y: position.y - 4,
          width: 10,
          height: 8,
          fill: 'black',
        };
      });
    });
  }
  return {
    ...ballot,
    pages: ballot.pages.map((page, i) => ({
      ...page,
      children: page.children.concat(marksForPage(i + 1)),
    })),
  };
}

export const famousNamesFixtures = (() => {
  const { electionDefinition, ballots } = layOutAllBallots({
    election: electionFamousNames2021Fixtures.election,
    isTestMode: true,
    layoutOptions: {
      bubblePosition: 'left',
      layoutDensity: 0,
    },
  }).unsafeUnwrap();

  const { precinctId, document: ballot, gridLayout } = ballots[0];

  const votes: VotesDict = Object.fromEntries(
    electionDefinition.election.contests.map((contest, i) => {
      assert(contest.type === 'candidate');
      const candidates = range(0, contest.seats).map(
        (j) => contest.candidates[(i + j) % contest.candidates.length]
      );
      return [contest.id, candidates];
    })
  );

  const markedBallot = markBallot({
    ballot,
    gridLayout,
    votes,
    contests: electionDefinition.election.contests,
    paperSize: BallotPaperSize.Letter,
    layoutDensity: 0,
  });

  // Saved PDFs generated by generate_fixtures.ts
  const blankBallotPath = join(famousNamesDir, 'blank-ballot.pdf');
  const markedBallotPath = join(famousNamesDir, 'marked-ballot.pdf');

  return {
    electionDefinition,
    precinctId,
    gridLayout,
    blankBallot: ballot,
    markedBallot,
    votes,
    blankBallotPath,
    markedBallotPath,
  };
})();

export const sampleElectionFixtures = (() => {
  const fixtures = [];

  const bubblePositions: BubblePosition[] = ['left', 'right'];
  const layoutDensities: LayoutDensity[] = [0, 1, 2];

  for (const bubblePosition of bubblePositions) {
    for (const paperSize of [BallotPaperSize.Letter, BallotPaperSize.Legal]) {
      for (const layoutDensity of layoutDensities) {
        const election: Election = {
          ...electionSample,
          ballotLayout: {
            ...electionSample.ballotLayout,
            paperSize,
          },
        };

        const { ballots, electionDefinition } = layOutAllBallots({
          election,
          isTestMode: true,
          layoutOptions: {
            bubblePosition,
            layoutDensity,
          },
        }).unsafeUnwrap();

        // Has ballot measures
        const ballotStyle = assertDefined(
          getBallotStyle({ election, ballotStyleId: '5' })
        );
        const precinctId = assertDefined(ballotStyle.precincts[0]);
        const { document: ballot, gridLayout } = find(
          ballots,
          (b) =>
            b.precinctId === precinctId &&
            b.gridLayout.ballotStyleId === ballotStyle.id
        );

        const contests = getContests({ election, ballotStyle });
        const votes: VotesDict = Object.fromEntries(
          contests.map((contest, i) => {
            if (contest.type === 'candidate') {
              const candidates = range(0, contest.seats).map(
                (j) => contest.candidates[(i + j) % contest.candidates.length]
              );
              return [contest.id, candidates];
            }
            return [contest.id, i % 2 === 0 ? ['yes'] : ['no']];
          })
        );

        const markedBallot = markBallot({
          ballot,
          gridLayout,
          votes,
          contests,
          paperSize,
          layoutDensity,
        });

        const electionDir = join(
          sampleElectionDir,
          `${bubblePosition}-${paperSize}-${layoutDensity}`
        );

        // Saved PDFs generated by generate_fixtures.ts
        const blankBallotPath = join(electionDir, 'blank-ballot.pdf');
        const markedBallotPath = join(electionDir, 'marked-ballot.pdf');

        fixtures.push({
          bubblePosition,
          paperSize,
          density: layoutDensity,
          electionDefinition,
          precinctId,
          gridLayout,
          blankBallot: ballot,
          markedBallot,
          votes,
          electionDir,
          blankBallotPath,
          markedBallotPath,
        });
      }
    }
  }

  return fixtures;
})();
