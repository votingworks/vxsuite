import { typedAs } from '@votingworks/basics';
import { JSONSchema4 } from 'json-schema';
import { mockWritable } from '../test/mock_writable';
import { buildSchema } from '.';

test('empty', () => {
  const out = mockWritable();

  buildSchema(
    `<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema elementFormDefault="qualified" targetNamespace="http://itl.nist.gov/ns/voting/1500-101/v1" version="1.0.2" xmlns="http://itl.nist.gov/ns/voting/1500-101/v1" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
</xsd:schema>
`,
    JSON.stringify(
      typedAs<JSONSchema4>({
        $schema: 'http://json-schema.org/draft-04/schema#',
        definitions: {},
      }),
      null,
      2
    ),
    out
  ).unsafeUnwrap();

  expect(out.toString()).toMatchInlineSnapshot(`
    "// DO NOT EDIT THIS FILE. IT IS GENERATED AUTOMATICALLY.

    /* eslint-disable */

    import { z } from 'zod';

    import check8601 from '@antongolub/iso8601';

    const Iso8601Date = z
      .string()
      .refine(check8601, 'dates must be in ISO8601 format');

    /**
     * Type for xsd:datetime values.
     */
    export type DateTime = z.TypeOf<typeof Iso8601Date>;

    /**
     * Schema for {@link DateTime}.
     */
    export const DateTimeSchema = Iso8601Date;

    /**
     * Type for xsd:date values.
     */
    export type Date = z.TypeOf<typeof Iso8601Date>;

    /**
     * Schema {@link Date}.
     */
    export const DateSchema = Iso8601Date;

    /**
     * A URI/URL.
     */
    export type Uri = string;

    /**
     * Schema for {@link Uri}.
     */
    export const UriSchema = z.string();

    /**
     * Byte data stored in a string.
     */
    export type Byte = string;

    /**
     * Schema for {@link Byte}.
     */
    export const ByteSchema = z.string();

    /**
     * An integer number, i.e. a whole number without fractional part.
     */
    export type integer = number;

    /**
     * Schema for {@link integer}.
     */
    export const integerSchema = z.number().int();

    "
  `);
});

test('invalid JSON schema', () => {
  expect(
    buildSchema(
      `<?xml version="1.0" encoding="UTF-8"?>
     <xsd:schema elementFormDefault="qualified" targetNamespace="http://itl.nist.gov/ns/voting/1500-101/v1" version="1.0.2" xmlns="http://itl.nist.gov/ns/voting/1500-101/v1" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
     </xsd:schema>`,
      `{}`,
      mockWritable()
    ).unsafeUnwrapErr()
  ).toEqual(new Error('JSON schema is missing definitions'));

  expect(
    buildSchema(
      `<?xml version="1.0" encoding="UTF-8"?>
     <xsd:schema elementFormDefault="qualified" targetNamespace="http://itl.nist.gov/ns/voting/1500-101/v1" version="1.0.2" xmlns="http://itl.nist.gov/ns/voting/1500-101/v1" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
     </xsd:schema>`,
      `{`,
      mockWritable()
    ).unsafeUnwrapErr()
  ).toBeInstanceOf(SyntaxError);
});

test('enum type', () => {
  const out = mockWritable();

  buildSchema(
    `<?xml version="1.0" encoding="UTF-8"?>
    <xsd:schema elementFormDefault="qualified" targetNamespace="http://itl.nist.gov/ns/voting/1500-101/v1" version="1.0.2" xmlns="http://itl.nist.gov/ns/voting/1500-101/v1" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
      <xsd:simpleType name="YesNo">
        <xsd:annotation>
          <xsd:documentation>YesNo is a simple enumeration of the values "yes" and "no".</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
          <xsd:enumeration value="yes">
            <xsd:annotation>
              <xsd:documentation>Yes</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
          <xsd:enumeration value="no">
            <xsd:annotation>
              <xsd:documentation>No</xsd:documentation>
            </xsd:annotation>
          </xsd:enumeration>
        </xsd:restriction>
      </xsd:simpleType>
    </xsd:schema>`,
    JSON.stringify(
      typedAs<JSONSchema4>({
        $schema: 'http://json-schema.org/draft-04/schema#',
        definitions: {
          YesNo: {
            type: 'string',
            enum: ['yes', 'no'],
          },
        },
      }),
      null,
      2
    ),
    out
  ).unsafeUnwrap();

  expect(out.toString()).toMatchInlineSnapshot(`
    "// DO NOT EDIT THIS FILE. IT IS GENERATED AUTOMATICALLY.

    /* eslint-disable */

    import { z } from 'zod';

    import check8601 from '@antongolub/iso8601';

    const Iso8601Date = z
      .string()
      .refine(check8601, 'dates must be in ISO8601 format');

    /**
     * Type for xsd:datetime values.
     */
    export type DateTime = z.TypeOf<typeof Iso8601Date>;

    /**
     * Schema for {@link DateTime}.
     */
    export const DateTimeSchema = Iso8601Date;

    /**
     * Type for xsd:date values.
     */
    export type Date = z.TypeOf<typeof Iso8601Date>;

    /**
     * Schema {@link Date}.
     */
    export const DateSchema = Iso8601Date;

    /**
     * A URI/URL.
     */
    export type Uri = string;

    /**
     * Schema for {@link Uri}.
     */
    export const UriSchema = z.string();

    /**
     * Byte data stored in a string.
     */
    export type Byte = string;

    /**
     * Schema for {@link Byte}.
     */
    export const ByteSchema = z.string();

    /**
     * An integer number, i.e. a whole number without fractional part.
     */
    export type integer = number;

    /**
     * Schema for {@link integer}.
     */
    export const integerSchema = z.number().int();

    /**
     * YesNo is a simple enumeration of the values "yes" and "no".
     */
    export enum YesNo {
      /**
       * Yes
       */
      Yes = 'yes',

      /**
       * No
       */
      No = 'no',
    }

    /**
     * Schema for {@link YesNo}.
     */
    export const YesNoSchema = z.nativeEnum(YesNo);

    "
  `);
});

test('object type', () => {
  const out = mockWritable();

  buildSchema(
    `<?xml version="1.0" encoding="UTF-8"?>
    <xsd:schema elementFormDefault="qualified" targetNamespace="http://itl.nist.gov/ns/voting/1500-101/v1" version="1.0.2" xmlns="http://itl.nist.gov/ns/voting/1500-101/v1" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
      <xsd:complexType name="Address">
        <xsd:annotation>
          <xsd:documentation>An address.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
          <xsd:element name="street" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>The street address.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="street2" type="xsd:string" minOccurs="0" maxOccurs="1" />
          <xsd:element name="city" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>The city.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="state" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>The state.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:complexType>
    </xsd:schema>`,
    JSON.stringify(
      typedAs<JSONSchema4>({
        $schema: 'http://json-schema.org/draft-04/schema#',
        definitions: {
          Address: {
            type: 'object',
            additionalProperties: false,
            properties: {
              street: {
                type: 'string',
              },
              street2: {
                type: 'string',
                minOccurs: 0,
                maxOccurs: 1,
              },
              city: {
                type: 'string',
              },
              state: {
                type: 'string',
              },
            },
          },
        },
      }),
      null,
      2
    ),
    out
  ).unsafeUnwrap();

  expect(out.toString()).toMatchInlineSnapshot(`
    "// DO NOT EDIT THIS FILE. IT IS GENERATED AUTOMATICALLY.

    /* eslint-disable */

    import { z } from 'zod';

    import check8601 from '@antongolub/iso8601';

    const Iso8601Date = z
      .string()
      .refine(check8601, 'dates must be in ISO8601 format');

    /**
     * Type for xsd:datetime values.
     */
    export type DateTime = z.TypeOf<typeof Iso8601Date>;

    /**
     * Schema for {@link DateTime}.
     */
    export const DateTimeSchema = Iso8601Date;

    /**
     * Type for xsd:date values.
     */
    export type Date = z.TypeOf<typeof Iso8601Date>;

    /**
     * Schema {@link Date}.
     */
    export const DateSchema = Iso8601Date;

    /**
     * A URI/URL.
     */
    export type Uri = string;

    /**
     * Schema for {@link Uri}.
     */
    export const UriSchema = z.string();

    /**
     * Byte data stored in a string.
     */
    export type Byte = string;

    /**
     * Schema for {@link Byte}.
     */
    export const ByteSchema = z.string();

    /**
     * An integer number, i.e. a whole number without fractional part.
     */
    export type integer = number;

    /**
     * Schema for {@link integer}.
     */
    export const integerSchema = z.number().int();

    /**
     * An address.
     */
    export interface Address {
      /**
       * The street address.
       */
      readonly street?: string;

      readonly street2?: string;

      /**
       * The city.
       */
      readonly city?: string;

      /**
       * The state.
       */
      readonly state?: string;
    }

    /**
     * Schema for {@link Address}.
     */
    export const AddressSchema: z.ZodSchema<Address> = z.object({
      street: z.optional(z.string()),
      street2: z.optional(z.string()),
      city: z.optional(z.string()),
      state: z.optional(z.string()),
    });

    "
  `);
});

test('object type property types', () => {
  const out = mockWritable();

  buildSchema(
    `<?xml version="1.0" encoding="UTF-8"?>
    <xsd:schema elementFormDefault="qualified" targetNamespace="http://itl.nist.gov/ns/voting/1500-101/v1" version="1.0.2" xmlns="http://itl.nist.gov/ns/voting/1500-101/v1" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
      <xsd:complexType name="AnObject">
        <xsd:sequence>
          <xsd:element name="@type" type="xsd:string"/>
          <xsd:element name="aString" type="xsd:string"/>
          <xsd:element name="aBoolean" type="xsd:boolean"/>
          <xsd:element name="aDecimal" type="xsd:decimal"/>
          <xsd:element name="aDate" type="xsd:date"/>
          <xsd:element name="aDateTime" type="xsd:dateTime"/>
          <xsd:element name="zeroOrMoreStrings" type="xsd:string" minOccurs="0" maxOccurs="unbounded"/>
          <xsd:element name="oneOrMoreStrings" type="xsd:string" minOccurs="1" maxOccurs="unbounded"/>
        </xsd:sequence>
      </xsd:complexType>
    </xsd:schema>`,
    JSON.stringify(
      typedAs<JSONSchema4>({
        $schema: 'http://json-schema.org/draft-04/schema#',
        definitions: {
          AnObject: {
            type: 'object',
            additionalProperties: false,
            required: ['@type', 'aString', 'aBoolean', 'aDecimal'],
            properties: {
              '@type': {
                type: 'string',
              },
              aString: {
                type: 'string',
              },
              aBoolean: {
                type: 'boolean',
              },
              aDecimal: {
                type: 'number',
              },
              aDate: {
                type: 'string',
                format: 'date',
              },
              aDateTime: {
                type: 'string',
                format: 'date-time',
              },
              zeroOrMoreStrings: {
                type: 'array',
                items: {
                  type: 'string',
                },
                minItems: 0,
              },
              oneOrMoreStrings: {
                type: 'array',
                items: {
                  type: 'string',
                },
                minItems: 1,
              },
            },
          },
        },
      }),
      null,
      2
    ),
    out
  ).unsafeUnwrap();

  expect(out.toString()).toMatchInlineSnapshot(`
    "// DO NOT EDIT THIS FILE. IT IS GENERATED AUTOMATICALLY.

    /* eslint-disable */

    import { z } from 'zod';

    import check8601 from '@antongolub/iso8601';

    const Iso8601Date = z
      .string()
      .refine(check8601, 'dates must be in ISO8601 format');

    /**
     * Type for xsd:datetime values.
     */
    export type DateTime = z.TypeOf<typeof Iso8601Date>;

    /**
     * Schema for {@link DateTime}.
     */
    export const DateTimeSchema = Iso8601Date;

    /**
     * Type for xsd:date values.
     */
    export type Date = z.TypeOf<typeof Iso8601Date>;

    /**
     * Schema {@link Date}.
     */
    export const DateSchema = Iso8601Date;

    /**
     * A URI/URL.
     */
    export type Uri = string;

    /**
     * Schema for {@link Uri}.
     */
    export const UriSchema = z.string();

    /**
     * Byte data stored in a string.
     */
    export type Byte = string;

    /**
     * Schema for {@link Byte}.
     */
    export const ByteSchema = z.string();

    /**
     * An integer number, i.e. a whole number without fractional part.
     */
    export type integer = number;

    /**
     * Schema for {@link integer}.
     */
    export const integerSchema = z.number().int();

    export interface AnObject {
      readonly '@type': string;

      readonly aString: string;

      readonly aBoolean: boolean;

      readonly aDecimal: number;

      readonly aDate?: Date;

      readonly aDateTime?: DateTime;

      readonly zeroOrMoreStrings?: readonly string[];

      readonly oneOrMoreStrings?: readonly string[];
    }

    /**
     * Schema for {@link AnObject}.
     */
    export const AnObjectSchema: z.ZodSchema<AnObject> = z.object({
      '@type': z.string(),
      aString: z.string(),
      aBoolean: z.boolean(),
      aDecimal: z.number(),
      aDate: z.optional(DateSchema),
      aDateTime: z.optional(DateTimeSchema),
      zeroOrMoreStrings: z.optional(z.array(z.string())),
      oneOrMoreStrings: z.optional(z.array(z.string()).min(1)),
    });

    "
  `);
});

test('object type references', () => {
  const out = mockWritable();

  buildSchema(
    `<?xml version="1.0" encoding="UTF-8"?>
    <xsd:schema elementFormDefault="qualified" targetNamespace="http://itl.nist.gov/ns/voting/1500-101/v1" version="1.0.2" xmlns="http://itl.nist.gov/ns/voting/1500-101/v1" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
      <xsd:complexType name="AnObject">
        <xsd:sequence>
          <xsd:element name="aString" type="xsd:string"/>
        </xsd:sequence>
      </xsd:complexType>
      <xsd:complexType name="AnotherObject">
        <xsd:sequence>
          <xsd:element name="anObject" type="AnObject"/>
        </xsd:sequence>
      </xsd:complexType>
    </xsd:schema>`,
    JSON.stringify(
      typedAs<JSONSchema4>({
        $schema: 'http://json-schema.org/draft-04/schema#',
        definitions: {
          AnObject: {
            type: 'object',
            additionalProperties: false,
            required: ['aString'],
            properties: {
              aString: {
                type: 'string',
              },
            },
          },
          AnotherObject: {
            type: 'object',
            additionalProperties: false,
            required: ['anObject'],
            properties: {
              anObject: {
                $ref: '#/definitions/AnObject',
              },
            },
          },
        },
      }),
      null,
      2
    ),
    out
  ).unsafeUnwrap();

  expect(out.toString()).toMatchInlineSnapshot(`
    "// DO NOT EDIT THIS FILE. IT IS GENERATED AUTOMATICALLY.

    /* eslint-disable */

    import { z } from 'zod';

    import check8601 from '@antongolub/iso8601';

    const Iso8601Date = z
      .string()
      .refine(check8601, 'dates must be in ISO8601 format');

    /**
     * Type for xsd:datetime values.
     */
    export type DateTime = z.TypeOf<typeof Iso8601Date>;

    /**
     * Schema for {@link DateTime}.
     */
    export const DateTimeSchema = Iso8601Date;

    /**
     * Type for xsd:date values.
     */
    export type Date = z.TypeOf<typeof Iso8601Date>;

    /**
     * Schema {@link Date}.
     */
    export const DateSchema = Iso8601Date;

    /**
     * A URI/URL.
     */
    export type Uri = string;

    /**
     * Schema for {@link Uri}.
     */
    export const UriSchema = z.string();

    /**
     * Byte data stored in a string.
     */
    export type Byte = string;

    /**
     * Schema for {@link Byte}.
     */
    export const ByteSchema = z.string();

    /**
     * An integer number, i.e. a whole number without fractional part.
     */
    export type integer = number;

    /**
     * Schema for {@link integer}.
     */
    export const integerSchema = z.number().int();

    export interface AnObject {
      readonly aString: string;
    }

    /**
     * Schema for {@link AnObject}.
     */
    export const AnObjectSchema: z.ZodSchema<AnObject> = z.object({
      aString: z.string(),
    });

    export interface AnotherObject {
      readonly anObject: AnObject;
    }

    /**
     * Schema for {@link AnotherObject}.
     */
    export const AnotherObjectSchema: z.ZodSchema<AnotherObject> = z.object({
      anObject: z.lazy(/* istanbul ignore next - @preserve */ () => AnObjectSchema),
    });

    "
  `);
});

test('string aliases', () => {
  const out = mockWritable();

  buildSchema(
    `<?xml version="1.0" encoding="UTF-8"?>
    <xsd:schema elementFormDefault="qualified" targetNamespace="http://itl.nist.gov/ns/voting/1500-101/v1" version="1.0.2" xmlns="http://itl.nist.gov/ns/voting/1500-101/v1" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
      <xsd:simpleType name="FractionalNumber">
        <xsd:annotation>
          <xsd:documentation xml:lang="en">A proper fractional value, represented using fractional or decimal notation.</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
          <xsd:pattern value="([0-9]+/[1-9]+[0-9]*)|(\\.[0-9]+)">
            <xsd:annotation>
              <xsd:documentation xml:lang="en">Pattern describing the allowed values for a FractionalNumber.</xsd:documentation>
            </xsd:annotation>
          </xsd:pattern>
        </xsd:restriction>
      </xsd:simpleType>
    </xsd:schema>`,
    JSON.stringify(
      typedAs<JSONSchema4>({
        $schema: 'http://json-schema.org/draft-04/schema#',
        definitions: {
          'CVR.FractionalNumber': {
            pattern: '([0-9]+/[1-9]+[0-9]*)|(\\.[0-9]+)',
            type: 'string',
          },
        },
      }),
      null,
      2
    ),
    out
  ).unsafeUnwrap();

  expect(out.toString()).toMatchInlineSnapshot(`
    "// DO NOT EDIT THIS FILE. IT IS GENERATED AUTOMATICALLY.

    /* eslint-disable */

    import { z } from 'zod';

    import check8601 from '@antongolub/iso8601';

    const Iso8601Date = z
      .string()
      .refine(check8601, 'dates must be in ISO8601 format');

    /**
     * Type for xsd:datetime values.
     */
    export type DateTime = z.TypeOf<typeof Iso8601Date>;

    /**
     * Schema for {@link DateTime}.
     */
    export const DateTimeSchema = Iso8601Date;

    /**
     * Type for xsd:date values.
     */
    export type Date = z.TypeOf<typeof Iso8601Date>;

    /**
     * Schema {@link Date}.
     */
    export const DateSchema = Iso8601Date;

    /**
     * A URI/URL.
     */
    export type Uri = string;

    /**
     * Schema for {@link Uri}.
     */
    export const UriSchema = z.string();

    /**
     * Byte data stored in a string.
     */
    export type Byte = string;

    /**
     * Schema for {@link Byte}.
     */
    export const ByteSchema = z.string();

    /**
     * An integer number, i.e. a whole number without fractional part.
     */
    export type integer = number;

    /**
     * Schema for {@link integer}.
     */
    export const integerSchema = z.number().int();

    /**
     * A proper fractional value, represented using fractional or decimal notation.
     */
    export type FractionalNumber = string;

    /**
     * Schema for {@link FractionalNumber}.
     */
    export const FractionalNumberSchema: z.ZodSchema<FractionalNumber> = z.string().regex(/([0-9]+\\/[1-9]+[0-9]*)|(\\.[0-9]+)/);

    "
  `);
});

test('documentation from JSON schema', () => {
  const out = mockWritable();

  buildSchema(
    `<?xml version="1.0" encoding="UTF-8"?>
    <xsd:schema elementFormDefault="qualified" targetNamespace="http://itl.nist.gov/ns/voting/1500-101/v1" version="1.0.2" xmlns="http://itl.nist.gov/ns/voting/1500-101/v1" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
    </xsd:schema>`,
    JSON.stringify(
      typedAs<JSONSchema4>({
        $schema: 'http://json-schema.org/draft-04/schema#',
        definitions: {
          'CVR.FractionalNumber': {
            type: 'string',
            pattern: '([0-9]+/[1-9]+[0-9]*)|(\\.[0-9]+)',
            description:
              'A proper fractional value, represented using fractional or decimal notation.',
          },
          'CVR.UndocumentedAlias': {
            type: 'string',
            pattern: '([0-9]+/[1-9]+[0-9]*)|(\\.[0-9]+)',
          },
          'CVR.YesNo': {
            type: 'string',
            enum: ['yes', 'no'],
            description: 'A boolean value.',
          },
          'CVR.UndocumentedEnum': {
            type: 'string',
            enum: ['yes', 'no'],
          },
          'CVR.AnObject': {
            type: 'object',
            additionalProperties: false,
            description: 'An object.',
            properties: {
              '@type': {
                type: 'string',
                description: 'The type of the object.',
              },
              aString: {
                type: 'string',
              },
              aBoolean: {
                type: 'boolean',
              },
              aDecimal: {
                type: 'number',
              },
              aDate: {
                type: 'string',
                format: 'date',
              },
              aDateTime: {
                type: 'string',
                format: 'date-time',
              },
              zeroOrMoreStrings: {
                type: 'string',
                minItems: 0,
                items: {
                  type: 'string',
                },
              },
              oneOrMoreStrings: {
                type: 'string',
                minItems: 1,
                items: {
                  type: 'string',
                },
              },
            },
          },
          'CVR.AnotherObject': {
            type: 'object',
            additionalProperties: false,
            properties: {
              '@type': {
                type: 'string',
              },
            },
          },
        },
      })
    ),
    out
  ).unsafeUnwrap();

  expect(out.toString()).toMatchInlineSnapshot(`
    "// DO NOT EDIT THIS FILE. IT IS GENERATED AUTOMATICALLY.

    /* eslint-disable */

    import { z } from 'zod';

    import check8601 from '@antongolub/iso8601';

    const Iso8601Date = z
      .string()
      .refine(check8601, 'dates must be in ISO8601 format');

    /**
     * Type for xsd:datetime values.
     */
    export type DateTime = z.TypeOf<typeof Iso8601Date>;

    /**
     * Schema for {@link DateTime}.
     */
    export const DateTimeSchema = Iso8601Date;

    /**
     * Type for xsd:date values.
     */
    export type Date = z.TypeOf<typeof Iso8601Date>;

    /**
     * Schema {@link Date}.
     */
    export const DateSchema = Iso8601Date;

    /**
     * A URI/URL.
     */
    export type Uri = string;

    /**
     * Schema for {@link Uri}.
     */
    export const UriSchema = z.string();

    /**
     * Byte data stored in a string.
     */
    export type Byte = string;

    /**
     * Schema for {@link Byte}.
     */
    export const ByteSchema = z.string();

    /**
     * An integer number, i.e. a whole number without fractional part.
     */
    export type integer = number;

    /**
     * Schema for {@link integer}.
     */
    export const integerSchema = z.number().int();

    /**
     * A proper fractional value, represented using fractional or decimal notation.
     */
    export type FractionalNumber = string;

    /**
     * Schema for {@link FractionalNumber}.
     */
    export const FractionalNumberSchema: z.ZodSchema<FractionalNumber> = z.string().regex(/([0-9]+\\/[1-9]+[0-9]*)|(\\.[0-9]+)/);

    export type UndocumentedAlias = string;

    /**
     * Schema for {@link UndocumentedAlias}.
     */
    export const UndocumentedAliasSchema: z.ZodSchema<UndocumentedAlias> = z.string().regex(/([0-9]+\\/[1-9]+[0-9]*)|(\\.[0-9]+)/);

    /**
     * A boolean value.
     */
    export enum YesNo {
      Yes = 'yes',

      No = 'no',
    }

    /**
     * Schema for {@link YesNo}.
     */
    export const YesNoSchema = z.nativeEnum(YesNo);

    export enum UndocumentedEnum {
      Yes = 'yes',

      No = 'no',
    }

    /**
     * Schema for {@link UndocumentedEnum}.
     */
    export const UndocumentedEnumSchema = z.nativeEnum(UndocumentedEnum);

    /**
     * An object.
     */
    export interface AnObject {
      /**
       * The type of the object.
       */
      readonly '@type'?: string;

      readonly aString?: string;

      readonly aBoolean?: boolean;

      readonly aDecimal?: number;

      readonly aDate?: Date;

      readonly aDateTime?: DateTime;

      readonly zeroOrMoreStrings?: string;

      readonly oneOrMoreStrings?: string;
    }

    /**
     * Schema for {@link AnObject}.
     */
    export const AnObjectSchema: z.ZodSchema<AnObject> = z.object({
      '@type': z.optional(z.string()),
      aString: z.optional(z.string()),
      aBoolean: z.optional(z.boolean()),
      aDecimal: z.optional(z.number()),
      aDate: z.optional(DateSchema),
      aDateTime: z.optional(DateTimeSchema),
      zeroOrMoreStrings: z.optional(z.string()),
      oneOrMoreStrings: z.optional(z.string()),
    });

    export interface AnotherObject {
      readonly '@type'?: string;
    }

    /**
     * Schema for {@link AnotherObject}.
     */
    export const AnotherObjectSchema: z.ZodSchema<AnotherObject> = z.object({
      '@type': z.optional(z.string()),
    });

    "
  `);
});
