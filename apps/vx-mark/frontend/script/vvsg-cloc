#!/usr/bin/env node

/**
 * Checks TypeScript files for adherence to the VVSG 1.0 spec regarding module
 * line count. Relevant language below:
 *
 * | Excluding code generated by commercial code generators, is written in
 * | small and easily identifiable modules, with no more than 50% of all modules
 * | exceeding 60 lines in length, no more than 5% of all modules exceeding 120
 * | lines in length, and no modules exceeding 240 lines in length. “Lines” in
 * | this context, are defined as executable statements or flow control
 * | statements with suitable formatting and comments. The reviewer should
 * | consider the use of formatting, such as blocking into readable units, which
 * | supports the intent of this requirement where the module itself exceeds the
 * | limits. The vendor shall justify any module lengths exceeding this standard
 *
 * Make sure you have the `cloc` package installed:
 *
 *   # Ubuntu
 *   apt-get install cloc
 *
 *   # macOS
 *   brew install cloc
 */

// @ts-check

const chalk = require('chalk')
const cp = require('child_process')
const { promisify } = require('util')
const { z } = require('zod')
const execFile = promisify(cp.execFile)

/**
 * CLOC per module with the maximum percentage of modules that meet or exceed
 * that amount.
 */
const minCLOCRequirements = new Map([
  [60, 0.5],
  [120, 0.05],
  [240, 0],
])

const StatsHeaderSchema = z.object({
  cloc_url: z.string(),
  cloc_version: z.string(),
  elapsed_seconds: z.number(),
  n_files: z.number(),
  n_lines: z.number(),
  files_per_second: z.number(),
  lines_per_second: z.number(),
})
const StatSummarySchema = z.object({
  blank: z.number(),
  comment: z.number(),
  code: z.number(),
  nFiles: z.number(),
})
const StatsMetaSchema = z.object({
  header: StatsHeaderSchema,
  SUM: StatSummarySchema,
})
const StatSchema = z.object({
  blank: z.number(),
  comment: z.number(),
  code: z.number(),
  language: z.string(),
})
const StatsSchema = z.record(StatSchema)

async function main(out = process.stdout) {
  const { stdout, stderr } = await execFile('cloc', [
    '--vcs',
    'git',
    '--json',
    '--by-file',
    '--include-lang=TypeScript',
    '--exclude-ext=test.ts,test.tsx'
  ])

  if (stderr.length) {
    console.error('ERROR:', stderr)
  }

  const { header: headerUnparsed, SUM: sumUnparsed, ...fileStatsUnparsed } = JSON.parse(stdout)
  const _header = StatsHeaderSchema.parse(headerUnparsed)
  const summary = StatSummarySchema.parse(sumUnparsed)
  const fileStats = StatsSchema.parse(fileStatsUnparsed)
  /** @type {Map<number, Set<[string, z.TypeOf<typeof StatSchema>]>>} */
  const filesByMinCLOC = new Map(
    [...minCLOCRequirements.keys()].map(minCLOC => [minCLOC, new Set()])
  )
  /** @type {Map<number, Set<[string, z.TypeOf<typeof StatSchema>]>>} */
  const filesByCLOCRange = new Map(
    [...minCLOCRequirements.keys()].map(minCLOC => [minCLOC, new Set()])
  )

  for (const [file, stat] of Object.entries(fileStats)) {
    const count = stat.code
    for (const [minCLOC, files] of filesByMinCLOC) {
      if (minCLOC <= count) {
        files.add([file, stat])
      }
    }

    for (const [minCLOC, files] of [...filesByCLOCRange].reverse()) {
      if (minCLOC <= count) {
        files.add([file, stat])
        break
      }
    }
  }

  for (const [minCLOC, files] of filesByCLOCRange) {
    out.write(`${chalk.bold(`${minCLOC}+ CLOC Files:`)}\n`)

    for (const [file, stat] of [...files].sort(
      ([, aStat], [, bStat]) => aStat.code - bStat.code
    )) {
      out.write(
        `${chalk.yellow(stat.code.toString().padStart(3, ' '))} ${file}\n`
      )
    }

    out.write('\n')
  }

  out.write(`${chalk.bold('Summary:')}\n`)

  for (const [minCLOC, files] of filesByMinCLOC) {
    const actual = files.size / summary.nFiles
    const expected = minCLOCRequirements.get(minCLOC)

    if (actual > expected) {
      process.exitCode = 1
    }

    out.write(`${formatCLOCStat(minCLOC, actual, expected)}\n`)
  }
}

/**
 *
 * @param {number} minCLOC
 * @param {number} actual
 * @param {number} expected
 */
function formatCLOCStat(minCLOC, actual, expected) {
  const color = actual <= expected ? chalk.green : chalk.red
  return color(
    `${minCLOC.toString().padStart(3, ' ')}+ CLOC: ${Math.round(actual * 100)
      .toString()
      .padStart(2, ' ')}% (<= ${Math.round(
        expected * 100
      ).toString()}% expected)`
  )
}

main().catch(error => {
  console.error(error)
  process.exitCode = -1
})
