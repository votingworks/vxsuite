import { afterAll, beforeEach, expect, test, vi } from 'vitest';
import { Buffer } from 'node:buffer';
import JsZip from 'jszip';
import get from 'lodash.get';
import {
  DateWithoutTime,
  assert,
  assertDefined,
  find,
  ok,
} from '@votingworks/basics';
import { readFileSync } from 'node:fs';
import {
  electionFamousNames2021Fixtures,
  electionPrimaryPrecinctSplitsFixtures,
  readElectionTwoPartyPrimaryDefinition,
} from '@votingworks/fixtures';
import {
  AdjudicationReason,
  HmpbBallotPaperSize,
  BallotType,
  CandidateContest,
  DEFAULT_SYSTEM_SETTINGS,
  Election,
  ElectionStringKey,
  SystemSettings,
  UiStringsPackage,
  formatBallotHash,
  formatElectionPackageHash,
  mergeUiStrings,
  LanguageCode,
  getAllBallotLanguages,
  ElectionPackageFileName,
  unsafeParse,
  ElectionIdSchema,
  DistrictIdSchema,
  ElectionId,
  getBallotLanguageConfigs,
  SplittablePrecinct,
  hasSplits,
  PrecinctWithSplits,
  PrecinctWithoutSplits,
  District,
} from '@votingworks/types';
import {
  BooleanEnvironmentVariableName,
  getBallotStylesByPrecinctId,
  getEntries,
  getFeatureFlagMock,
  getFileByName,
  openZip,
  readJsonEntry,
} from '@votingworks/utils';
import {
  forEachUiString,
  isMockCloudSynthesizedSpeech,
  mockCloudTranslatedText,
  readElectionPackageFromBuffer,
} from '@votingworks/backend';
import {
  countObjectLeaves,
  getObjectLeaves,
  suppressingConsoleOutput,
} from '@votingworks/test-utils';
import {
  allBaseBallotProps,
  BallotMode,
  ballotTemplates,
  BaseBallotProps,
  hmpbStringsCatalog,
  renderAllBallotsAndCreateElectionDefinition,
  RenderDocument,
} from '@votingworks/hmpb';
import {
  ELECTION_PACKAGE_FILE_NAME_REGEX,
  exportElectionPackage,
  processNextBackgroundTaskIfAny,
  testSetupHelpers,
  unzipElectionPackageAndBallots,
} from '../test/helpers';
import { FULL_TEST_DECK_TALLY_REPORT_FILE_NAME } from './test_decks';
import {
  BallotOrderInfo,
  BallotStyle,
  User,
  convertToVxfBallotStyle,
} from './types';
import { generateBallotStyles } from './ballot_styles';
import { ElectionRecord } from '.';
import { ElectionPackage } from './store';
import { renderBallotStyleReadinessReport } from './ballot_style_reports';
import {
  BALLOT_STYLE_READINESS_REPORT_FILE_NAME,
  convertVxfPrecincts,
} from './app';
import { join } from 'node:path';
import { electionFeatureConfigs, userFeatureConfigs } from './features';
import { sliOrgId } from './globals';
import { election } from '@votingworks/fixtures/src/builders';

vi.setConfig({
  testTimeout: 60_000,
});

const vxUser: User = { orgId: 'votingworks' };
const nonVxUser: User = { orgId: '123' };

const mockFeatureFlagger = getFeatureFlagMock();

vi.mock(import('@votingworks/utils'), async (importActual) => ({
  ...(await importActual()),
  isFeatureFlagEnabled: (flag) => mockFeatureFlagger.isEnabled(flag),
}));

vi.mock('./ballot_style_reports.js');

// Spy on the ballot rendering function so we can check that it's called with the
// right arguments.
vi.mock(import('@votingworks/hmpb'), async (importActual) => {
  const original = await importActual();
  return {
    ...original,
    renderAllBallotsAndCreateElectionDefinition: vi.fn(
      original.renderAllBallotsAndCreateElectionDefinition
    ),
  } as unknown as typeof original;
});

const { setupApp, cleanup } = testSetupHelpers();

const MOCK_READINESS_REPORT_CONTENTS = '%PDF - MockReadinessReport';
const MOCK_READINESS_REPORT_PDF = Buffer.from(
  MOCK_READINESS_REPORT_CONTENTS,
  'utf-8'
);

function expectedEnglishBallotStrings(election: Election): UiStringsPackage {
  const expectedStrings = mergeUiStrings(election.ballotStrings, {
    [LanguageCode.ENGLISH]: hmpbStringsCatalog,
  });
  // Ballot style IDs are generated by VxDesign and then translated
  expectedStrings[LanguageCode.ENGLISH]!['ballotStyleId'] = Object.fromEntries(
    election.ballotStyles.map(({ id, groupId }) => [id, groupId])
  );
  return expectedStrings;
}

afterAll(cleanup);

beforeEach(() => {
  mockFeatureFlagger.resetFeatureFlags();

  vi.mocked(renderBallotStyleReadinessReport).mockResolvedValue(
    MOCK_READINESS_REPORT_PDF
  );
});

test('CRUD elections', async () => {
  const { apiClient } = await setupApp();
  expect(await apiClient.listElections({ user: vxUser })).toEqual([]);

  const expectedElectionId = unsafeParse(ElectionIdSchema, 'election-1');
  const electionId = (
    await apiClient.createElection({
      id: expectedElectionId,
      user: vxUser,
      orgId: nonVxUser.orgId,
    })
  ).unsafeUnwrap();
  expect(electionId).toEqual(expectedElectionId);

  const election = await apiClient.getElection({ electionId, user: vxUser });
  // New elections should be blank
  expect(election).toEqual<ElectionRecord>({
    orgId: nonVxUser.orgId,
    election: {
      id: expectedElectionId,
      ballotLayout: {
        metadataEncoding: 'qr-code',
        paperSize: HmpbBallotPaperSize.Letter,
      },
      ballotStyles: [],
      contests: [],
      county: {
        id: 'county-id',
        name: '',
      },
      date: expect.any(DateWithoutTime),
      districts: [],
      parties: [],
      precincts: [],
      seal: '',
      state: '',
      title: '',
      type: 'general',
      ballotStrings: {},
    },
    systemSettings: DEFAULT_SYSTEM_SETTINGS,
    ballotOrderInfo: {},
    ballotStyles: [],
    precincts: [],
    createdAt: expect.any(String),
    ballotsFinalizedAt: null,
    ballotLanguageConfigs: getBallotLanguageConfigs([LanguageCode.ENGLISH]),
    ballotTemplateId: 'NhBallot',
  });

  expect(await apiClient.listElections({ user: vxUser })).toEqual([election]);
  expect(await apiClient.listElections({ user: nonVxUser })).toEqual([
    election,
  ]);

  const election2Definition =
    electionFamousNames2021Fixtures.readElectionDefinition();

  const importedElectionNewId = 'new-election-id' as ElectionId;
  const electionId2 = (
    await apiClient.loadElection({
      user: vxUser,
      newId: importedElectionNewId,
      orgId: nonVxUser.orgId,
      electionData: election2Definition.electionData,
    })
  ).unsafeUnwrap();
  expect(electionId2).toEqual(importedElectionNewId);

  const election2 = await apiClient.getElection({
    user: vxUser,
    electionId: electionId2,
  });

  const expectedPrecincts: SplittablePrecinct[] =
    election2Definition.election.precincts.map((vxfPrecinct) => ({
      id: vxfPrecinct.id,
      name: vxfPrecinct.name,
      districtIds: [unsafeParse(DistrictIdSchema, 'district-1')],
    }));
  const expectedBallotStyles: BallotStyle[] = generateBallotStyles({
    ballotLanguageConfigs: election2.ballotLanguageConfigs,
    contests: election2Definition.election.contests,
    electionType: election2Definition.election.type,
    parties: election2Definition.election.parties,
    precincts: expectedPrecincts,
  });

  expect(election2).toEqual<ElectionRecord>({
    orgId: nonVxUser.orgId,
    election: {
      ...election2Definition.election,
      id: importedElectionNewId,
      ballotStyles: expectedBallotStyles.map(convertToVxfBallotStyle),
      gridLayouts: undefined, // Grid layouts should be stripped out
    },
    systemSettings: DEFAULT_SYSTEM_SETTINGS,
    ballotOrderInfo: {},
    // TODO test that ballot styles/precincts are correct
    ballotStyles: expectedBallotStyles,
    precincts: expectedPrecincts,
    createdAt: expect.any(String),
    ballotsFinalizedAt: null,
    ballotLanguageConfigs: getBallotLanguageConfigs([LanguageCode.ENGLISH]),
    ballotTemplateId: 'VxDefaultBallot',
  });

  expect(await apiClient.listElections({ user: vxUser })).toEqual([
    election2,
    election,
  ]);

  const updatedElection: Election = {
    ...election.election,
    title: 'Updated Election',
    type: 'primary',
  };

  await apiClient.updateElection({
    electionId,
    election: updatedElection,
  });

  expect(await apiClient.getElection({ user: vxUser, electionId })).toEqual({
    ...election,
    election: updatedElection,
  });

  await apiClient.deleteElection({ electionId });

  expect(await apiClient.listElections({ user: vxUser })).toEqual([election2]);
});

test('update election info', async () => {
  const { apiClient } = await setupApp();
  const electionId = unsafeParse(ElectionIdSchema, 'election-1');
  (
    await apiClient.createElection({
      user: vxUser,
      orgId: nonVxUser.orgId,
      id: electionId,
    })
  ).unsafeUnwrap();

  await apiClient.updateElectionInfo({
    electionId,
    // trim text values
    title: '   Updated Election  ',
    jurisdiction: '   New Hampshire   ',
    state: '   NH   ',
    seal: '\r\n<svg>updated seal</svg>\r\n',
    type: 'primary',
    date: new DateWithoutTime('2022-01-01'),
    languageCodes: [LanguageCode.ENGLISH, LanguageCode.SPANISH],
  });

  const record = await apiClient.getElection({ user: vxUser, electionId });
  const { election, ballotLanguageConfigs } = record;
  expect(election.title).toEqual('Updated Election');
  expect(election.type).toEqual('primary');
  expect(election.state).toEqual('NH');
  expect(election.county.name).toEqual('New Hampshire');
  expect(election.seal).toEqual('\r\n<svg>updated seal</svg>\r\n');
  expect(election.date).toEqual(new DateWithoutTime('2022-01-01'));
  expect(ballotLanguageConfigs).toEqual([
    { languages: [LanguageCode.ENGLISH] },
    { languages: [LanguageCode.SPANISH] },
  ]);

  // empty string values are rejected
  await suppressingConsoleOutput(() =>
    expect(
      apiClient.updateElectionInfo({
        electionId,
        type: 'primary',
        title: '',
        jurisdiction: '  ',
        state: '',
        seal: '',
        date: new DateWithoutTime('2022-01-01'),
        languageCodes: [LanguageCode.ENGLISH],
      })
    ).rejects.toThrow()
  );
});

test('CRUD districts', async () => {
  const { apiClient } = await setupApp();
  const electionId = (
    await apiClient.createElection({
      user: vxUser,
      orgId: nonVxUser.orgId,
      id: unsafeParse(ElectionIdSchema, 'election-1'),
    })
  ).unsafeUnwrap();

  // No districts initially
  expect(await apiClient.listDistricts({ electionId })).toEqual([]);

  // Create a district
  const district1: District = {
    id: unsafeParse(DistrictIdSchema, 'district-1'),
    name: 'District 1',
  };
  await apiClient.createDistrict({
    electionId,
    newDistrict: district1,
  });
  expect(await apiClient.listDistricts({ electionId })).toEqual([district1]);

  // Create another district
  const district2: District = {
    id: unsafeParse(DistrictIdSchema, 'district-2'),
    name: 'District 2',
  };
  await apiClient.createDistrict({
    electionId,
    newDistrict: district2,
  });
  expect(await apiClient.listDistricts({ electionId })).toEqual([
    district1,
    district2,
  ]);

  // Update a district
  const updatedDistrict1: District = {
    ...district1,
    name: 'Updated District 1',
  };
  await apiClient.updateDistrict({
    electionId,
    updatedDistrict: updatedDistrict1,
  });
  expect(await apiClient.listDistricts({ electionId })).toEqual([
    updatedDistrict1,
    district2,
  ]);

  // Delete a district
  await apiClient.deleteDistrict({
    electionId,
    districtId: district2.id,
  });
  expect(await apiClient.listDistricts({ electionId })).toEqual([
    updatedDistrict1,
  ]);

  // Try to create an invalid district
  await suppressingConsoleOutput(() =>
    expect(
      apiClient.createDistrict({
        electionId,
        newDistrict: {
          id: unsafeParse(DistrictIdSchema, 'district-1'),
          name: '',
        },
      })
    ).rejects.toThrow()
  );

  // Try to update a district that doesn't exist
  await suppressingConsoleOutput(() =>
    expect(
      apiClient.updateDistrict({
        electionId,
        updatedDistrict: {
          ...district1,
          id: unsafeParse(DistrictIdSchema, 'invalid-id'),
        },
      })
    ).rejects.toThrow()
  );

  // Try to delete a district that doesn't exist
  await suppressingConsoleOutput(() =>
    expect(
      apiClient.deleteDistrict({
        electionId,
        districtId: unsafeParse(DistrictIdSchema, 'invalid-id'),
      })
    ).rejects.toThrow()
  );
});

test('deleting a district updates associated precincts', async () => {
  const baseElectionDefinition =
    electionPrimaryPrecinctSplitsFixtures.readElectionDefinition();
  const { apiClient } = await setupApp();
  const electionId = (
    await apiClient.loadElection({
      user: vxUser,
      newId: 'new-election-id' as ElectionId,
      orgId: nonVxUser.orgId,
      electionData: baseElectionDefinition.electionData,
    })
  ).unsafeUnwrap();

  // Delete a district associated with a precinct with splits
  const precincts = (await apiClient.getElection({ user: vxUser, electionId }))
    .precincts;
  const precinctWithSplits = precincts.find(hasSplits)!;
  const split = precinctWithSplits.splits[0];
  await apiClient.deleteDistrict({
    electionId,
    districtId: split.districtIds[0],
  });
  let updatedPrecincts = (
    await apiClient.getElection({ user: vxUser, electionId })
  ).precincts;
  let updatedPrecinct = updatedPrecincts.find(
    (p) => p.id === precinctWithSplits.id
  )!;
  assert(hasSplits(updatedPrecinct));
  const updatedSplit = updatedPrecinct.splits[0];
  expect(updatedSplit.districtIds).not.toContain(split.districtIds[0]);

  // Delete a district associated with a precinct without splits
  const precinctWithoutSplits = updatedPrecincts.find(
    (p) => !hasSplits(p)
  ) as PrecinctWithoutSplits;
  await apiClient.deleteDistrict({
    electionId,
    districtId: precinctWithoutSplits.districtIds[0],
  });
  updatedPrecincts = (await apiClient.getElection({ user: vxUser, electionId }))
    .precincts;
  updatedPrecinct = updatedPrecincts.find(
    (p) => p.id === precinctWithoutSplits.id
  )!;
  assert(!hasSplits(updatedPrecinct));
  expect(updatedPrecinct.districtIds).not.toContain(
    precinctWithoutSplits.districtIds[0]
  );
});

test('CRUD precincts', async () => {
  const { apiClient } = await setupApp();
  const electionId = (
    await apiClient.createElection({
      user: vxUser,
      orgId: nonVxUser.orgId,
      id: unsafeParse(ElectionIdSchema, 'election-1'),
    })
  ).unsafeUnwrap();

  // No precincts initially
  expect(await apiClient.listPrecincts({ electionId })).toEqual([]);

  // Create a precinct
  const precinct1: PrecinctWithoutSplits = {
    id: 'precinct-1',
    name: 'Precinct 1',
    districtIds: [], // Ok to have no districts
  };
  await apiClient.createPrecinct({
    electionId,
    newPrecinct: precinct1,
  });
  expect(await apiClient.listPrecincts({ electionId })).toEqual([precinct1]);

  // Add a district to the precinct
  const district1: District = {
    id: unsafeParse(DistrictIdSchema, 'district-1'),
    name: 'District 1',
  };
  await apiClient.createDistrict({
    electionId,
    newDistrict: district1,
  });
  const updatedPrecinct1: PrecinctWithoutSplits = {
    ...precinct1,
    districtIds: [district1.id],
  };
  await apiClient.updatePrecinct({
    electionId,
    precinctId: precinct1.id,
    updatedPrecinct: updatedPrecinct1,
  });
  expect(await apiClient.listPrecincts({ electionId })).toEqual([
    updatedPrecinct1,
  ]);

  // Create another precinct with splits
  const precinct2: PrecinctWithSplits = {
    id: 'precinct-2',
    name: 'Precinct 2',
    splits: [
      {
        id: 'split-1',
        name: 'Split 1',
        districtIds: [district1.id],
      },
      {
        id: 'split-2',
        name: 'Split 2',
        districtIds: [],
      },
    ],
  };
  await apiClient.createPrecinct({
    electionId,
    newPrecinct: precinct2,
  });
  expect(await apiClient.listPrecincts({ electionId })).toEqual([
    updatedPrecinct1,
    precinct2,
  ]);

  // Update splits
  const district2: District = {
    id: unsafeParse(DistrictIdSchema, 'district-2'),
    name: 'District 2',
  };
  await apiClient.createDistrict({
    electionId,
    newDistrict: district2,
  });
  const updatedPrecinct2: PrecinctWithSplits = {
    ...precinct2,
    splits: [
      {
        ...precinct2.splits[0],
        districtIds: [district2.id],
      },
      precinct2.splits[1],
    ],
  };
  await apiClient.updatePrecinct({
    electionId,
    precinctId: precinct2.id,
    updatedPrecinct: updatedPrecinct2,
  });
  expect(await apiClient.listPrecincts({ electionId })).toEqual([
    updatedPrecinct1,
    updatedPrecinct2,
  ]);

  // Delete a precinct
  await apiClient.deletePrecinct({
    electionId,
    precinctId: precinct1.id,
  });
  expect(await apiClient.listPrecincts({ electionId })).toEqual([
    updatedPrecinct2,
  ]);

  // Try to create an invalid precinct
  await suppressingConsoleOutput(async () => {
    await expect(
      apiClient.createPrecinct({
        electionId,
        newPrecinct: {
          id: 'precinct-1',
          name: '',
          districtIds: [],
        },
      })
    ).rejects.toThrow();
    await expect(
      apiClient.createPrecinct({
        electionId,
        newPrecinct: {
          id: 'precinct-1',
          name: 'Precinct 1',
          districtIds: [unsafeParse(DistrictIdSchema, 'invalid-id')],
        },
      })
    ).rejects.toThrow();
    await expect(
      apiClient.createPrecinct({
        electionId,
        newPrecinct: {
          id: 'precinct-1',
          name: 'Precinct 1',
          splits: [
            {
              id: 'split-1',
              name: 'Split 1',
              districtIds: [unsafeParse(DistrictIdSchema, 'invalid-id')],
            },
          ],
        },
      })
    ).rejects.toThrow();
  });

  // Try to update a precinct that doesn't exist
  await suppressingConsoleOutput(() =>
    expect(
      apiClient.updatePrecinct({
        electionId,
        precinctId: 'invalid-id',
        updatedPrecinct: precinct1,
      })
    ).rejects.toThrow()
  );

  // Try to delete a precinct that doesn't exist
  await suppressingConsoleOutput(() =>
    expect(
      apiClient.deletePrecinct({
        electionId,
        precinctId: 'invalid-id',
      })
    ).rejects.toThrow()
  );
});

test('Updating contests with candidate rotation', async () => {
  const { apiClient } = await setupApp();
  const electionId = (
    await apiClient.loadElection({
      user: vxUser,
      newId: 'new-election-id' as ElectionId,
      orgId: nonVxUser.orgId,
      electionData: electionFamousNames2021Fixtures.electionJson.asText(),
    })
  ).unsafeUnwrap();
  let electionRecord = await apiClient.getElection({
    user: vxUser,
    electionId,
  });
  let contest = electionRecord.election.contests.find(
    (c): c is CandidateContest =>
      c.type === 'candidate' && c.candidates.length > 2
  )!;
  expect(contest.candidates.map((c) => c.name)).toMatchInlineSnapshot(`
[
  "Winston Churchill",
  "Oprah Winfrey",
  "Louis Armstrong",
]
`);

  // Update with no changes just to trigger candidate rotation
  // No rotation should occur for the default ballot template
  await apiClient.updateElection({
    electionId,
    election: electionRecord.election,
  });
  electionRecord = await apiClient.getElection({
    user: vxUser,
    electionId,
  });
  contest = electionRecord.election.contests.find(
    (c): c is CandidateContest => c.id === contest.id
  )!;
  expect(contest.candidates.map((c) => c.name)).toMatchInlineSnapshot(`
    [
      "Winston Churchill",
      "Oprah Winfrey",
      "Louis Armstrong",
    ]
  `);

  // Switch to the NH ballot template to trigger rotation
  await apiClient.setBallotTemplate({
    electionId,
    ballotTemplateId: 'NhBallot',
  });
  await apiClient.updateElection({
    electionId,
    election: electionRecord.election,
  });
  electionRecord = await apiClient.getElection({
    user: vxUser,
    electionId,
  });
  const updatedContest = electionRecord.election.contests.find(
    (c): c is CandidateContest => c.id === contest.id
  )!;
  expect(updatedContest.candidates.map((c) => c.name)).toMatchInlineSnapshot(`
[
  "Louis Armstrong",
  "Winston Churchill",
  "Oprah Winfrey",
]
`);

  // Rotation logic is tested in candidate_rotation.test.ts
  // Here we just want to make sure that rotation occurred.
  expect(updatedContest.candidates).not.toEqual(contest.candidates);
  expect(updatedContest.candidates.length).toEqual(contest.candidates.length);
  expect(new Set(updatedContest.candidates)).toEqual(
    new Set(contest.candidates)
  );
});

test('Update system settings', async () => {
  const { apiClient } = await setupApp();
  const electionId = unsafeParse(ElectionIdSchema, 'election-1');
  (
    await apiClient.createElection({
      user: vxUser,
      orgId: nonVxUser.orgId,
      id: electionId,
    })
  ).unsafeUnwrap();
  const electionRecord = await apiClient.getElection({
    user: vxUser,
    electionId,
  });

  expect(electionRecord.systemSettings).toEqual(DEFAULT_SYSTEM_SETTINGS);

  const updatedSystemSettings: SystemSettings = {
    ...electionRecord.systemSettings,
    markThresholds: {
      definite: 0.9,
      marginal: 0.8,
    },
    precinctScanAdjudicationReasons: [AdjudicationReason.Overvote],
    centralScanAdjudicationReasons: [
      AdjudicationReason.Undervote,
      AdjudicationReason.MarginalMark,
    ],
  };
  expect(updatedSystemSettings).not.toEqual(DEFAULT_SYSTEM_SETTINGS);

  await apiClient.updateSystemSettings({
    electionId,
    systemSettings: updatedSystemSettings,
  });

  expect(await apiClient.getElection({ user: vxUser, electionId })).toEqual({
    ...electionRecord,
    systemSettings: updatedSystemSettings,
  });
});

test('Update ballot order info', async () => {
  const { apiClient } = await setupApp();
  const electionId = unsafeParse(ElectionIdSchema, 'election-1');
  (
    await apiClient.createElection({
      user: vxUser,
      orgId: nonVxUser.orgId,
      id: electionId,
    })
  ).unsafeUnwrap();

  const electionRecord = await apiClient.getElection({
    user: vxUser,
    electionId,
  });
  expect(electionRecord.ballotOrderInfo).toEqual({});

  const updateBallotOrderInfo: BallotOrderInfo = {
    absenteeBallotCount: '100',
    deliveryAddress: '123 Main St, Town, NH, 00000',
    deliveryRecipientName: 'Clerky Clerkson',
    ballotColor: 'Yellow for town, white for school',
    precinctBallotCount: '200',
    shouldAbsenteeBallotsBeScoredForFolding: true,
  };
  await apiClient.updateBallotOrderInfo({
    electionId,
    ballotOrderInfo: updateBallotOrderInfo,
  });

  expect(await apiClient.getElection({ user: vxUser, electionId })).toEqual({
    ...electionRecord,
    ballotOrderInfo: updateBallotOrderInfo,
  });
});

test('Finalize ballots', async () => {
  const { apiClient } = await setupApp();
  const electionId = (
    await apiClient.loadElection({
      user: vxUser,
      newId: 'new-election-id' as ElectionId,
      orgId: nonVxUser.orgId,
      electionData: electionFamousNames2021Fixtures.electionJson.asText(),
    })
  ).unsafeUnwrap();

  expect(await apiClient.getBallotsFinalizedAt({ electionId })).toEqual(null);

  const finalizedAt = new Date();
  await apiClient.finalizeBallots({ electionId });

  expect(
    (await apiClient.getBallotsFinalizedAt({ electionId }))!.valueOf() / 1000
  ).toBeCloseTo(finalizedAt.valueOf() / 1000);

  await apiClient.unfinalizeBallots({ electionId });

  expect(await apiClient.getBallotsFinalizedAt({ electionId })).toEqual(null);
});

test('cloneElection', async () => {
  const { apiClient, workspace } = await setupApp({
    auth: {
      hasAccess(user: User, orgId: string): boolean {
        if (user.orgId === vxUser.orgId) {
          return true;
        }

        return user.orgId === orgId;
      },
    },
  });

  const srcElection =
    electionFamousNames2021Fixtures.electionJson.readElection();

  const nonDefaultSystemSettings: SystemSettings = {
    ...DEFAULT_SYSTEM_SETTINGS,
    auth: {
      ...DEFAULT_SYSTEM_SETTINGS.auth,
      arePollWorkerCardPinsEnabled: true,
    },
  };

  const srcPrecincts = convertVxfPrecincts(srcElection);
  await workspace.store.createElection(
    nonVxUser.orgId,
    srcElection,
    srcPrecincts,
    'VxDefaultBallot',
    nonDefaultSystemSettings
  );
  await apiClient.finalizeBallots({ electionId: srcElection.id });
  const srcElectionRecord = await workspace.store.getElection(srcElection.id);

  // Vx user can clone from any org to another:
  const newElectionId = await apiClient.cloneElection({
    destId: 'election-clone-1' as ElectionId,
    destOrgId: 'dest-org-id',
    srcId: srcElection.id,
    user: vxUser,
  });
  expect(newElectionId).toEqual('election-clone-1');

  const destElectionRecord = await workspace.store.getElection(
    'election-clone-1' as ElectionId
  );
  expect(destElectionRecord.election).toEqual({
    ...srcElectionRecord.election,
    id: 'election-clone-1',
    title: `(Copy) ${srcElectionRecord.election.title}`,
  });
  expect(destElectionRecord.ballotTemplateId).toEqual('VxDefaultBallot');
  expect(destElectionRecord.orgId).toEqual('dest-org-id');
  expect(destElectionRecord.systemSettings).toEqual(
    srcElectionRecord.systemSettings
  );
  expect(destElectionRecord.precincts).toEqual(srcElectionRecord.precincts);

  expect(destElectionRecord.ballotsFinalizedAt).toBeNull();
  expect(destElectionRecord.createdAt).not.toEqual(srcElectionRecord.createdAt);

  // Non-Vx user can clone from and to their own org:
  await expect(
    apiClient.cloneElection({
      destId: 'election-clone-2' as ElectionId,
      destOrgId: nonVxUser.orgId,
      srcId: srcElection.id,
      user: nonVxUser,
    })
  ).resolves.toEqual('election-clone-2');

  // Non-VX user can't clone from another org:
  const anotherNonVxUser = { ...nonVxUser, orgId: 'another-org-id' };
  await expect(
    apiClient.cloneElection({
      destId: 'election-clone-3' as ElectionId,
      destOrgId: nonVxUser.orgId,
      srcId: srcElection.id,
      user: anotherNonVxUser,
    })
  ).rejects.toEqual(
    expect.objectContaining({
      message: expect.stringContaining('Access denied'),
    })
  );

  // Non-VX user can't clone from their org to another:
  await expect(
    apiClient.cloneElection({
      destId: 'election-clone-3' as ElectionId,
      destOrgId: anotherNonVxUser.orgId,
      srcId: srcElection.id,
      user: nonVxUser,
    })
  ).rejects.toEqual(
    expect.objectContaining({
      message: expect.stringContaining('Access denied'),
    })
  );
});

test('Election package management', async () => {
  const baseElectionDefinition =
    electionFamousNames2021Fixtures.readElectionDefinition();
  const { apiClient, workspace, fileStorageClient } = await setupApp();

  const electionId = (
    await apiClient.loadElection({
      user: vxUser,
      newId: 'new-election-id' as ElectionId,
      orgId: nonVxUser.orgId,
      electionData: baseElectionDefinition.electionData,
    })
  ).unsafeUnwrap();
  const election = await apiClient.getElection({ user: vxUser, electionId });

  // Without mocking all the translations some ballot styles for non-English languages don't fit on a letter
  // page for this election. To get around this we use legal paper size for the purposes of this test.
  await apiClient.updateElection({
    electionId,
    election: {
      ...election.election,
      ballotLayout: {
        ...election.election.ballotLayout,
        paperSize: HmpbBallotPaperSize.Legal,
      },
    },
  });

  const electionPackageBeforeExport = await apiClient.getElectionPackage({
    electionId,
  });
  expect(electionPackageBeforeExport).toEqual({});

  // Initiate an export
  await apiClient.exportElectionPackage({
    electionId,
    electionSerializationFormat: 'vxf',
    shouldExportAudio: false,
  });
  const expectedPayload = JSON.stringify({
    electionId,
    electionSerializationFormat: 'vxf',
    shouldExportAudio: false,
  });
  const electionPackageAfterInitiatingExport =
    await apiClient.getElectionPackage({ electionId });
  expect(electionPackageAfterInitiatingExport).toEqual<ElectionPackage>({
    task: {
      createdAt: expect.any(Date),
      id: expect.any(String),
      payload: expectedPayload,
      taskName: 'generate_election_package',
    },
  });
  const taskId = assertDefined(electionPackageAfterInitiatingExport.task).id;

  // Check that initiating an export before a prior has completed doesn't trigger a new background
  // task (even with a different serialization format)
  await apiClient.exportElectionPackage({
    electionId,
    electionSerializationFormat: 'cdf',
    shouldExportAudio: false,
  });
  const electionPackageAfterInitiatingRedundantExport =
    await apiClient.getElectionPackage({ electionId });
  expect(electionPackageAfterInitiatingRedundantExport).toEqual(
    electionPackageAfterInitiatingExport
  );

  // Complete an export
  await processNextBackgroundTaskIfAny({ fileStorageClient, workspace });
  const electionPackageAfterExport = await apiClient.getElectionPackage({
    electionId,
  });
  expect(electionPackageAfterExport).toEqual<ElectionPackage>({
    task: {
      completedAt: expect.any(Date),
      createdAt: expect.any(Date),
      id: taskId,
      payload: expectedPayload,
      startedAt: expect.any(Date),
      taskName: 'generate_election_package',
    },
    url: expect.stringMatching(ELECTION_PACKAGE_FILE_NAME_REGEX),
  });

  // Check that initiating an export after a prior has completed does trigger a new background task
  await apiClient.exportElectionPackage({
    electionId,
    electionSerializationFormat: 'vxf',
    shouldExportAudio: false,
  });
  const electionPackageAfterInitiatingSecondExport =
    await apiClient.getElectionPackage({ electionId });
  expect(electionPackageAfterInitiatingSecondExport).toEqual<ElectionPackage>({
    task: {
      createdAt: expect.any(Date),
      id: expect.any(String),
      payload: expectedPayload,
      taskName: 'generate_election_package',
    },
    url: expect.stringMatching(ELECTION_PACKAGE_FILE_NAME_REGEX),
  });
  const secondTaskId = assertDefined(
    electionPackageAfterInitiatingSecondExport.task
  ).id;
  expect(secondTaskId).not.toEqual(taskId);
});

test('Election package and ballots export', async () => {
  const baseElectionDefinition =
    electionFamousNames2021Fixtures.readElectionDefinition();
  // Without mocking all the translations some ballot styles for non-English languages don't fit on a letter
  // page for this election. To get around this we use legal paper size for the purposes of this test.
  const electionWithLegalPaper: Election = {
    ...baseElectionDefinition.election,
    ballotLayout: {
      ...baseElectionDefinition.election.ballotLayout,
      paperSize: HmpbBallotPaperSize.Legal,
    },
  };
  const mockSystemSettings: SystemSettings = {
    ...DEFAULT_SYSTEM_SETTINGS,
    precinctScanAdjudicationReasons: [
      AdjudicationReason.Overvote,
      AdjudicationReason.UnmarkedWriteIn,
    ],
  };
  const { apiClient, workspace, fileStorageClient } = await setupApp();

  const electionId = (
    await apiClient.loadElection({
      user: vxUser,
      newId: 'new-election-id' as ElectionId,
      orgId: nonVxUser.orgId,
      electionData: JSON.stringify(electionWithLegalPaper),
    })
  ).unsafeUnwrap();
  await apiClient.updateSystemSettings({
    electionId,
    systemSettings: mockSystemSettings,
  });
  const electionRecord = await apiClient.getElection({
    user: vxUser,
    electionId,
  });

  const {
    ballotStyles,
    precincts,
    ballotLanguageConfigs,
    election: appElection,
  } = electionRecord;

  const electionPackageFilePath = await exportElectionPackage({
    fileStorageClient,
    apiClient,
    electionId,
    workspace,
    electionSerializationFormat: 'vxf',
    shouldExportAudio: true,
  });
  const contents = assertDefined(
    fileStorageClient.getRawFile(
      join(electionRecord.orgId, electionPackageFilePath)
    )
  );
  const { electionPackageContents, ballotsContents } =
    await unzipElectionPackageAndBallots(contents);
  const { electionPackage, electionPackageHash } = (
    await readElectionPackageFromBuffer(electionPackageContents)
  ).unsafeUnwrap();
  const {
    electionDefinition,
    metadata,
    systemSettings,
    uiStringAudioClips,
    uiStringAudioIds,
    uiStrings,
  } = electionPackage;
  assert(metadata !== undefined);
  assert(systemSettings !== undefined);
  assert(uiStringAudioClips !== undefined);
  assert(uiStringAudioIds !== undefined);
  assert(uiStrings !== undefined);

  const [, ballotHashFromFileName, electionPackageHashFromFileName] =
    electionPackageFilePath.match(ELECTION_PACKAGE_FILE_NAME_REGEX)!;
  expect(electionPackageHashFromFileName).toEqual(
    formatElectionPackageHash(electionPackageHash)
  );
  expect(ballotHashFromFileName).toEqual(
    formatBallotHash(electionDefinition.ballotHash)
  );

  //
  // Check metadata
  //

  expect(metadata.version).toEqual('latest');

  //
  // Check election definition
  //
  const expectedElection: Election = {
    ...electionWithLegalPaper,

    id: electionId,

    // Ballot styles are generated in the app, ignoring the ones in the inputted election
    // definition
    ballotStyles: appElection.ballotStyles,

    // The base election definition should have been extended with grid layouts. The correctness of
    // the grid layouts is tested by libs/ballot-interpreter tests.
    gridLayouts: expect.any(Array),

    // Translated strings for election content and HMPB content should have been
    // added to the election. so they can be included in the ballot hash.
    ballotStrings: expect.objectContaining({
      ...expectedEnglishBallotStrings(appElection),
    }),
    additionalHashInput: {
      precinctSplitSeals: expect.any(Object),
      precinctSplitSignatureImages: expect.any(Object),
    },
  };

  expect(electionDefinition.election).toEqual(expectedElection);

  //
  // Check system settings
  //

  expect(systemSettings).toEqual(mockSystemSettings);

  //
  // Check UI strings
  //

  const allBallotLanguages = getAllBallotLanguages(ballotLanguageConfigs);
  for (const languageCode of allBallotLanguages) {
    expect(countObjectLeaves(uiStrings[languageCode] ?? {})).toBeGreaterThan(
      // A number high enough to give us confidence that we've exported both app and election strings
      200
    );
  }

  for (const electionStringKey of Object.values(ElectionStringKey)) {
    // The current election definition doesn't include any yes-no contests or contest terms
    if (
      electionStringKey === ElectionStringKey.CONTEST_DESCRIPTION ||
      electionStringKey === ElectionStringKey.CONTEST_OPTION_LABEL ||
      electionStringKey === ElectionStringKey.CONTEST_TERM
    ) {
      continue;
    }

    expect(
      assertDefined(uiStrings[LanguageCode.ENGLISH])[electionStringKey]
    ).toBeDefined();
  }

  const stringsInEnglish: Array<{
    stringKey: string | [string, string];
    stringInEnglish: string;
  }> = [];
  forEachUiString(
    uiStrings,
    ({ languageCode, stringKey, stringInLanguage }) => {
      if (languageCode === LanguageCode.ENGLISH) {
        stringsInEnglish.push({ stringKey, stringInEnglish: stringInLanguage });
      }
    }
  );

  // Verify that strings were translated as expected
  for (const languageCode of allBallotLanguages) {
    if (languageCode === LanguageCode.ENGLISH) {
      continue;
    }

    for (const { stringKey, stringInEnglish } of stringsInEnglish) {
      const stringInLanguage = get(uiStrings, [languageCode, stringKey].flat());
      if (
        Array.isArray(stringKey) &&
        stringKey[0] === ElectionStringKey.BALLOT_STYLE_ID
      ) {
        expect(stringInLanguage).not.toBeDefined();
      } else if (
        Array.isArray(stringKey) &&
        stringKey[0] === ElectionStringKey.CANDIDATE_NAME
      ) {
        expect(stringInLanguage).not.toBeDefined();
      } else if (stringKey === ElectionStringKey.ELECTION_DATE) {
        expect(stringInLanguage).toBeDefined();
      } else if (stringKey === ElectionStringKey.BALLOT_LANGUAGE) {
        expect(stringInLanguage).toBeDefined();
      } else {
        expect(stringInLanguage).toBeDefined();
        expect(stringInLanguage).toEqual(
          mockCloudTranslatedText(stringInEnglish, languageCode)
        );
      }
    }
  }

  //
  // Check uiStringAudioIds.json
  //
  expect(countObjectLeaves(uiStringAudioIds)).toEqual(
    countObjectLeaves(uiStrings) -
      Object.keys(hmpbStringsCatalog).length * allBallotLanguages.length
  );

  //
  // Check audioClips.jsonl
  //

  const audioIds: Set<string> = new Set(
    getObjectLeaves(uiStringAudioIds)
      .flat()
      .filter((audioId): audioId is string => {
        assert(typeof audioId === 'string');
        return !(audioId.startsWith('{{') && audioId.endsWith('}}'));
      })
  );
  const audioIdsInAudioClipsFile = new Set(
    uiStringAudioClips.map(({ id }) => id)
  );
  expect(audioIdsInAudioClipsFile.size).toEqual(audioIds.size);
  for (const audioId of audioIds) {
    expect(audioIdsInAudioClipsFile.has(audioId)).toEqual(true);
  }

  for (const { dataBase64 } of uiStringAudioClips) {
    expect(
      isMockCloudSynthesizedSpeech(
        Buffer.from(dataBase64, 'base64').toString('utf-8')
      )
    ).toEqual(true);
  }

  //
  // Check ballots ZIP
  //
  const zip = await JsZip.loadAsync(ballotsContents);

  const expectedFileNames = [
    BALLOT_STYLE_READINESS_REPORT_FILE_NAME,
    ...ballotStyles
      .flatMap(({ id, precinctsOrSplits }) =>
        precinctsOrSplits.map((p) => ({
          ballotStyleId: id,
          precinctId: p.precinctId,
        }))
      )
      .flatMap(({ ballotStyleId, precinctId }) => {
        const precinctName = find(
          precincts,
          (p) => p.id === precinctId
        ).name.replaceAll(' ', '_');

        const suffix = `ballot-${precinctName}-${ballotStyleId}.pdf`;

        return [
          `official-precinct-${suffix}`,
          `test-precinct-${suffix}`,
          `sample-precinct-${suffix}`,
          `official-absentee-${suffix}`,
          `test-absentee-${suffix}`,
          `sample-absentee-${suffix}`,
        ];
      }),
  ].sort();
  expect(Object.keys(zip.files).sort()).toEqual(expectedFileNames);

  const readinessReportFileContents =
    await zip.files[BALLOT_STYLE_READINESS_REPORT_FILE_NAME].async('text');
  expect(readinessReportFileContents).toContain(MOCK_READINESS_REPORT_CONTENTS);

  // Ballot appearance is tested by fixtures in libs/hmpb, so we
  // just make sure we got a PDF and that we called the layout function with the
  // right arguments.
  for (const file of Object.values(zip.files)) {
    expect(await file.async('text')).toContain('%PDF');
  }
  expect(renderAllBallotsAndCreateElectionDefinition).toHaveBeenCalledTimes(1);
  const ballotCombos: Array<[BallotType, BallotMode]> = [
    [BallotType.Precinct, 'official'],
    [BallotType.Precinct, 'test'],
    [BallotType.Precinct, 'sample'],
    [BallotType.Absentee, 'official'],
    [BallotType.Absentee, 'test'],
    [BallotType.Absentee, 'sample'],
  ];
  const expectedBallotProps = appElection.ballotStyles.flatMap((ballotStyle) =>
    ballotStyle.precincts.flatMap((precinctId) =>
      ballotCombos.map(
        ([ballotType, ballotMode]): BaseBallotProps => ({
          election: {
            ...appElection,
            ballotStrings: expectedEnglishBallotStrings(appElection),
            additionalHashInput: {
              precinctSplitSeals: expect.any(Object),
              precinctSplitSignatureImages: expect.any(Object),
            },
          },
          ballotStyleId: ballotStyle.id,
          precinctId,
          ballotType,
          ballotMode,
        })
      )
    )
  );
  expect(renderAllBallotsAndCreateElectionDefinition).toHaveBeenCalledWith(
    expect.any(Object), // Renderer
    ballotTemplates.VxDefaultBallot,
    expectedBallotProps,
    'vxf'
  );
});

test('Export test decks', async () => {
  const electionDefinition = readElectionTwoPartyPrimaryDefinition();
  const { apiClient } = await setupApp();

  const electionId = (
    await apiClient.loadElection({
      user: vxUser,
      newId: 'new-election-id' as ElectionId,
      orgId: nonVxUser.orgId,
      electionData: electionDefinition.electionData,
    })
  ).unsafeUnwrap();
  const { election } = await apiClient.getElection({
    user: vxUser,
    electionId,
  });

  const { zipContents } = await apiClient.exportTestDecks({
    electionId,
    electionSerializationFormat: 'vxf',
  });
  const zip = await JsZip.loadAsync(zipContents);

  const precinctsWithBallots = election.precincts.filter(
    (precinct) =>
      getBallotStylesByPrecinctId(electionDefinition, precinct.id).length > 0
  );
  expect(Object.keys(zip.files).sort()).toEqual(
    [
      ...precinctsWithBallots.map(
        (precinct) => `${precinct.name.replaceAll(' ', '_')}-test-ballots.pdf`
      ),
      FULL_TEST_DECK_TALLY_REPORT_FILE_NAME,
    ].sort()
  );

  // We test the actual test deck content in test_decks.ts
  for (const file of Object.values(zip.files)) {
    expect(await file.async('text')).toContain('%PDF');
  }
  expect(renderAllBallotsAndCreateElectionDefinition).toHaveBeenCalledTimes(1);
  const expectedBallotProps = election.ballotStyles.flatMap((ballotStyle) =>
    ballotStyle.precincts.map((precinctId) => ({
      election: {
        ...election,
        ballotStrings: expectedEnglishBallotStrings(election),
        additionalHashInput: {
          precinctSplitSeals: {},
          precinctSplitSignatureImages: {},
        },
      },
      ballotStyleId: ballotStyle.id,
      precinctId,
      ballotType: BallotType.Precinct,
      ballotMode: 'test',
    }))
  );
  expect(renderAllBallotsAndCreateElectionDefinition).toHaveBeenCalledWith(
    expect.any(Object), // Renderer
    ballotTemplates.VxDefaultBallot,
    expectedBallotProps,
    'vxf'
  );
});

test('Consistency of ballot hash across exports', async () => {
  const baseElectionDefinition =
    electionFamousNames2021Fixtures.readElectionDefinition();
  const { apiClient, workspace, fileStorageClient } = await setupApp();

  const electionId = (
    await apiClient.loadElection({
      user: vxUser,
      newId: 'new-election-id' as ElectionId,
      orgId: nonVxUser.orgId,
      electionData: baseElectionDefinition.electionData,
    })
  ).unsafeUnwrap();

  const testDecksOutput = await apiClient.exportTestDecks({
    electionId,
    electionSerializationFormat: 'vxf',
  });

  const electionPackageAndBallotsFilePath = await exportElectionPackage({
    fileStorageClient,
    apiClient,
    electionId,
    workspace,
    electionSerializationFormat: 'vxf',
    shouldExportAudio: false,
  });
  const contents = assertDefined(
    fileStorageClient.getRawFile(
      join(nonVxUser.orgId, electionPackageAndBallotsFilePath)
    )
  );
  const { electionPackageContents, electionPackageFileName, ballotsFileName } =
    await unzipElectionPackageAndBallots(contents);
  const { electionDefinition } = (
    await readElectionPackageFromBuffer(electionPackageContents)
  ).unsafeUnwrap().electionPackage;
  const electionPackageZipBallotHash = electionPackageFileName.match(
    'election-package-(.*)-.*.zip'
  )![1];
  const ballotsZipBallotHash = ballotsFileName.match('ballots-(.*).zip')![1];

  expect(electionDefinition.ballotHash).toEqual(testDecksOutput.ballotHash);
  expect(electionPackageZipBallotHash).toEqual(ballotsZipBallotHash);
  expect(formatBallotHash(electionDefinition.ballotHash)).toEqual(
    electionPackageZipBallotHash
  );
});

test('CDF exports', async () => {
  const baseElectionDefinition =
    electionFamousNames2021Fixtures.readElectionDefinition();
  const { apiClient, workspace, fileStorageClient } = await setupApp();

  const electionId = (
    await apiClient.loadElection({
      user: vxUser,
      newId: 'new-election-id' as ElectionId,
      orgId: nonVxUser.orgId,
      electionData: baseElectionDefinition.electionData,
    })
  ).unsafeUnwrap();

  const testDecksOutput = await apiClient.exportTestDecks({
    electionId,
    electionSerializationFormat: 'cdf',
  });

  const electionPackageAndBallotsFilePath = await exportElectionPackage({
    fileStorageClient,
    apiClient,
    electionId,
    workspace,
    electionSerializationFormat: 'cdf',
    shouldExportAudio: false,
  });
  const contents = assertDefined(
    fileStorageClient.getRawFile(
      join(nonVxUser.orgId, electionPackageAndBallotsFilePath)
    )
  );
  const { electionPackageContents } =
    await unzipElectionPackageAndBallots(contents);
  const { electionDefinition } = (
    await readElectionPackageFromBuffer(electionPackageContents)
  ).unsafeUnwrap().electionPackage;
  expect(electionDefinition.electionData).toMatch(
    /"@type": "BallotDefinition.BallotDefinition"/
  );

  expect(electionDefinition.ballotHash).toEqual(testDecksOutput.ballotHash);
});

test('getBallotPreviewPdf returns a ballot pdf for precinct with splits', async () => {
  const baseElectionDefinition =
    electionPrimaryPrecinctSplitsFixtures.readElectionDefinition();
  const { apiClient } = await setupApp();

  const electionId = (
    await apiClient.loadElection({
      user: vxUser,
      newId: 'new-election-id' as ElectionId,
      orgId: nonVxUser.orgId,
      electionData: baseElectionDefinition.electionData,
    })
  ).unsafeUnwrap();
  const { ballotStyles, precincts } = await apiClient.getElection({
    user: vxUser,
    electionId,
  });

  const precinct = assertDefined(precincts.find((p) => hasSplits(p)));
  const split = precinct.splits[0];
  const ballotStyle = assertDefined(
    ballotStyles.find((style) => {
      const matchingSplit = style.precinctsOrSplits.find(
        (p) => p.precinctId === precinct.id && p.splitId === split.id
      );
      return !!matchingSplit && style.languages.includes(LanguageCode.ENGLISH);
    })
  );

  const result = (
    await apiClient.getBallotPreviewPdf({
      electionId,
      precinctId: precinct.id,
      ballotStyleId: ballotStyle.id,
      ballotType: BallotType.Precinct,
      ballotMode: 'test',
    })
  ).unsafeUnwrap();

  await expect(result.pdfData).toMatchPdfSnapshot();
});

test('getBallotPreviewPdf returns a ballot pdf for NH election with split precincts and additional config options', async () => {
  const baseElectionDefinition =
    electionPrimaryPrecinctSplitsFixtures.readElectionDefinition();
  const election: Election = {
    ...baseElectionDefinition.election,
    state: 'New Hampshire',
  };
  const { apiClient } = await setupApp();

  const electionId = (
    await apiClient.loadElection({
      user: vxUser,
      newId: 'new-election-id' as ElectionId,
      orgId: nonVxUser.orgId,
      electionData: JSON.stringify(election),
    })
  ).unsafeUnwrap();
  const { ballotStyles, precincts } = await apiClient.getElection({
    user: vxUser,
    electionId,
  });

  const splitPrecinctIndex = precincts.findIndex((p) => hasSplits(p));
  assert(splitPrecinctIndex >= 0);
  const precinct = precincts[splitPrecinctIndex] as PrecinctWithSplits;
  const split = precinct.splits[0];
  split.clerkSignatureCaption = 'Test Clerk Caption';
  split.clerkSignatureImage = readFileSync(
    './test/mockSignature.svg'
  ).toString();
  split.electionTitleOverride = 'Test Election Title Override';

  await apiClient.updatePrecinct({
    electionId,
    precinctId: precinct.id,
    updatedPrecinct: precinct,
  });

  const ballotStyle = assertDefined(
    ballotStyles.find((style) => {
      const matchingSplit = style.precinctsOrSplits.find(
        (p) => p.precinctId === precinct.id && p.splitId === split.id
      );
      return !!matchingSplit && style.languages.includes(LanguageCode.ENGLISH);
    })
  );

  const result = (
    await apiClient.getBallotPreviewPdf({
      electionId,
      precinctId: precinct.id,
      ballotStyleId: ballotStyle.id,
      ballotType: BallotType.Precinct,
      ballotMode: 'test',
    })
  ).unsafeUnwrap();

  await expect(result.pdfData).toMatchPdfSnapshot({ failureThreshold: 0.001 });
});

test('getBallotPreviewPdf returns a ballot pdf for precinct with no split', async () => {
  const baseElectionDefinition =
    electionFamousNames2021Fixtures.readElectionDefinition();
  const { apiClient } = await setupApp();

  const electionId = (
    await apiClient.loadElection({
      user: vxUser,
      newId: 'new-election-id' as ElectionId,
      orgId: nonVxUser.orgId,
      electionData: baseElectionDefinition.electionData,
    })
  ).unsafeUnwrap();
  const { ballotStyles, precincts } = await apiClient.getElection({
    user: vxUser,
    electionId,
  });

  function hasDistrictIds(
    precinct: SplittablePrecinct
  ): precinct is PrecinctWithoutSplits {
    return 'districtIds' in precinct && precinct.districtIds.length > 0;
  }

  const precinct = assertDefined(precincts.find((p) => hasDistrictIds(p)));

  const result = (
    await apiClient.getBallotPreviewPdf({
      electionId,
      precinctId: precinct.id,
      ballotStyleId: assertDefined(
        ballotStyles.find(
          (style) =>
            style.districtIds.includes(precinct.districtIds[0]) &&
            style.languages.includes(LanguageCode.ENGLISH)
        )
      ).id,
      ballotType: BallotType.Precinct,
      ballotMode: 'test',
    })
  ).unsafeUnwrap();

  await expect(result.pdfData).toMatchPdfSnapshot({ failureThreshold: 0.01 });
});

function mockBallotDocument(): RenderDocument {
  return {
    getContent: vi.fn(),
    inspectElements: vi.fn(),
    renderToPdf: vi.fn().mockResolvedValue(Buffer.from('')),
    setContent: vi.fn(),
  };
}

test('setBallotTemplate changes the ballot template used to render ballots', async () => {
  const electionDefinition =
    electionFamousNames2021Fixtures.readElectionDefinition();
  const { apiClient, fileStorageClient, workspace } = await setupApp();
  const electionId = (
    await apiClient.loadElection({
      user: vxUser,
      newId: 'new-election-id' as ElectionId,
      orgId: nonVxUser.orgId,
      electionData: electionDefinition.electionData,
    })
  ).unsafeUnwrap();
  const electionRecord = await apiClient.getElection({
    user: vxUser,
    electionId,
  });
  expect(electionRecord.ballotTemplateId).toEqual('VxDefaultBallot');

  await apiClient.setBallotTemplate({
    electionId,
    ballotTemplateId: 'NhBallot',
  });

  expect(await apiClient.getElection({ user: vxUser, electionId })).toEqual({
    ...electionRecord,
    ballotTemplateId: 'NhBallot',
  });

  const props = allBaseBallotProps(electionDefinition.election);
  vi.mocked(renderAllBallotsAndCreateElectionDefinition).mockResolvedValue({
    ballotDocuments: props.map(mockBallotDocument),
    electionDefinition,
  });
  await exportElectionPackage({
    fileStorageClient,
    apiClient,
    electionId,
    workspace,
    electionSerializationFormat: 'vxf',
    shouldExportAudio: false,
  });
  expect(renderAllBallotsAndCreateElectionDefinition).toHaveBeenCalledWith(
    expect.any(Object), // Renderer
    ballotTemplates.NhBallot,
    expect.any(Array), // Ballot props
    'vxf'
  );
  expect(
    vi.mocked(renderAllBallotsAndCreateElectionDefinition).mock.calls[0][2]
  ).toHaveLength(props.length);
  vi.mocked(renderAllBallotsAndCreateElectionDefinition).mockRestore();
});

test('v3-compatible election package', async () => {
  const fixtureElectionDefinition =
    electionFamousNames2021Fixtures.readElectionDefinition();
  const fixtureElection = fixtureElectionDefinition.election;
  const { apiClient, workspace, fileStorageClient } = await setupApp();
  const electionId = (
    await apiClient.loadElection({
      user: vxUser,
      newId: 'new-election-id' as ElectionId,
      orgId: nonVxUser.orgId,
      electionData: fixtureElectionDefinition.electionData,
    })
  ).unsafeUnwrap();
  await apiClient.setBallotTemplate({
    electionId,
    ballotTemplateId: 'NhBallotV3',
  });

  const electionPackageAndBallotsFileName = await exportElectionPackage({
    fileStorageClient,
    apiClient,
    electionId,
    workspace,
    electionSerializationFormat: 'vxf',
    shouldExportAudio: false,
  });
  const electionPackageAndBallotsZip = await openZip(
    fileStorageClient.getRawFile(
      join(nonVxUser.orgId, electionPackageAndBallotsFileName)
    )!
  );
  const electionPackageAndBallotsZipEntries = getEntries(
    electionPackageAndBallotsZip
  );
  const electionPackageZipBuffer = await find(
    electionPackageAndBallotsZipEntries,
    (entry) => entry.name.startsWith('election-package')
  ).async('nodebuffer');
  const electionPackageZip = await openZip(electionPackageZipBuffer);
  const electionPackageZipEntries = getEntries(electionPackageZip);
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const election: any = await readJsonEntry(
    getFileByName(electionPackageZipEntries, ElectionPackageFileName.ELECTION)
  );
  // Date should be off-by-one to account for timezone bug in v3
  expect(fixtureElection.date.toISOString()).toEqual('2021-06-06');
  expect(election.date).toEqual('2021-06-07');

  // System settings should have field names matching v3 format
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const systemSettings: any = await readJsonEntry(
    getFileByName(
      electionPackageZipEntries,
      ElectionPackageFileName.SYSTEM_SETTINGS
    )
  );
  expect(Object.keys(systemSettings)).toEqual([
    'auth',
    'markThresholds',
    'centralScanAdjudicationReasons',
    'precinctScanAdjudicationReasons',
    'precinctScanDisallowCastingOvervotes',
  ]);

  // No other files included
  expect(electionPackageAndBallotsZipEntries.length).toEqual(2);
});

test('feature configs', async () => {
  const sliUser: User = { orgId: sliOrgId() };
  const { apiClient } = await setupApp();
  expect(await apiClient.getUserFeatures({ user: vxUser })).toEqual(
    userFeatureConfigs.vx
  );
  expect(await apiClient.getUserFeatures({ user: nonVxUser })).toEqual(
    userFeatureConfigs.nh
  );
  expect(await apiClient.getUserFeatures({ user: sliUser })).toEqual(
    userFeatureConfigs.sli
  );

  const vxElectionId = (
    await apiClient.createElection({
      id: 'vx-election-id' as ElectionId,
      user: vxUser,
      orgId: vxUser.orgId,
    })
  ).unsafeUnwrap();
  const nonVxElectionId = (
    await apiClient.createElection({
      id: 'non-vx-election-id' as ElectionId,
      user: nonVxUser,
      orgId: nonVxUser.orgId,
    })
  ).unsafeUnwrap();
  const sliElectionId = (
    await apiClient.createElection({
      id: 'sli-election-id' as ElectionId,
      user: sliUser,
      orgId: sliUser.orgId,
    })
  ).unsafeUnwrap();
  expect(
    await apiClient.getElectionFeatures({ electionId: vxElectionId })
  ).toEqual(electionFeatureConfigs.vx);
  expect(
    await apiClient.getElectionFeatures({ electionId: nonVxElectionId })
  ).toEqual(electionFeatureConfigs.nh);
  expect(
    await apiClient.getElectionFeatures({ electionId: sliElectionId })
  ).toEqual(electionFeatureConfigs.sli);
});
